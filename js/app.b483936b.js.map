{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/lua/rust-lua/src/main.rs","webpack:///./src/App.vue?2f82","webpack:///./src/components/Editor.vue?83a6","webpack:///src/components/Editor.vue","webpack:///./src/components/Editor.vue?edde","webpack:///./src/components/Editor.vue","webpack:///./src/components/Output.vue?1f0a","webpack:///./src/lua/lua.js","webpack:///./src/lua/index.js","webpack:///src/components/Output.vue","webpack:///./src/components/Output.vue?4e03","webpack:///./src/components/Output.vue","webpack:///src/App.vue","webpack:///./src/App.vue?a63f","webpack:///./src/App.vue","webpack:///./src/main.js","webpack:///./src/App.vue?fc19","webpack:///./src/components/Editor.vue?e60e","webpack:///./src/components/Output.vue?890d"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","1","exports","module","l","m","c","d","name","getter","o","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","p","jsonpArray","window","oldJsonpFunction","bind","slice","process","Buffer","existingModule","initialize","userDefinedModule","Promise","resolve","reject","Module","assign","key","moduleOverrides","status","toThrow","nodeFS","nodePath","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","Error","importScripts","filename","binary","ret","toString","buffer","Uint8Array","assert","replace","ex","ExitStatus","reason","read","f","readbuffer","scriptArgs","arguments","quit","url","xhr","XMLHttpRequest","open","send","responseText","responseType","response","onload","onerror","title","document","console","log","print","printErr","warn","undefined","STACK_ALIGN","staticAlloc","size","staticSealed","STATICTOP","dynamicAlloc","DYNAMICTOP_PTR","HEAP32","end","TOTAL_MEMORY","success","enlargeMemory","alignMemory","factor","Math","ceil","getNativeTypeSize","type","bits","parseInt","substr","warnOnce","text","shown","stackSave","stackRestore","stackAlloc","setTempRet0","abort","Array","GLOBAL_BASE","ABORT","condition","getCFunc","ident","func","JSfuncs","arrayToC","arr","writeArrayToMemory","stringToC","str","len","stringToUTF8","toC","string","array","ccall","returnType","argTypes","args","opts","cArgs","stack","converter","Pointer_stringify","Boolean","cwrap","cfunc","numericArgs","every","numericRet","setValue","ptr","noSafe","charAt","HEAP8","HEAP16","tempI64","tempDouble","Math_abs","Math_min","Math_floor","Math_ceil","HEAPF32","HEAPF64","ALLOC_NORMAL","ALLOC_STATIC","ALLOC_NONE","allocate","slab","types","allocator","zeroinit","singleType","_malloc","max","stop","subarray","HEAPU8","set","typeSize","previousType","curr","t","hasUtf","MAX_CHUNK","String","fromCharCode","min","UTF8ToString","UTF8Decoder","TextDecoder","UTF8ArrayToString","u8Array","idx","endPtr","decode","u0","u1","u2","u3","u4","u5","ch","stringToUTF8Array","outU8Array","outIdx","maxBytesToWrite","startIdx","endIdx","u","charCodeAt","outPtr","lengthBytesUTF8","allocateUTF8","demangle","demangleAll","regex","x","y","jsStackTrace","err","e","stackTrace","js","HEAPU32","STATIC_BASE","STACK_BASE","STACKTOP","STACK_MAX","DYNAMIC_BASE","WASM_PAGE_SIZE","ASMJS_PAGE_SIZE","alignUp","multiple","updateGlobalBuffer","buf","updateGlobalBufferViews","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","writeStackCookie","checkStackCookie","abortStackOverflow","allocSize","abortOnCannotGrowMemory","TOTAL_STACK","getTotalMemory","byteLength","WebAssembly","Memory","initial","maximum","ArrayBuffer","callRuntimeCallbacks","callbacks","callback","arg","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATEXIT__","__ATPOSTRUN__","runtimeInitialized","runtimeExited","preRun","addOnPreRun","ensureInitRuntime","preMain","exitRuntime","postRun","addOnPostRun","cb","unshift","addOnInit","writeAsciiToMemory","dontAddNull","abs","cos","sin","tan","acos","asin","atan","atan2","exp","sqrt","floor","Math_pow","pow","imul","fround","round","runDependencies","clz32","trunc","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","getUniqueRunDependency","id","orig","random","addRunDependency","setInterval","clearInterval","dep","removeRunDependency","dataURIPrefix","isDataURI","startsWith","indexOf","integrateWasmJS","wasmTextFile","wasmBinaryFile","asmjsCodeFile","wasmPageSize","info","global","env","asm2wasm","f64-rem","debugger","parent","mergeMemory","newBuffer","oldBuffer","oldView","newView","fixImports","imports","getBinary","getBinaryPromise","fetch","credentials","then","catch","doNativeWasm","providedBuffer","receiveInstance","instance","memory","NaN","Infinity","trueModule","receiveInstantiatedSource","output","instantiateArrayBuffer","receiver","instantiate","instantiateStreaming","asmjsReallocBuffer","wasmReallocBuffer","PAGE_MULTIPLE","old","oldSize","grow","error","finalMethod","TABLE_SIZE","MAX_TABLE_SIZE","Table","element","ASM_CONSTS","$0","$1","STDWEB_PRIVATE","to_js","from_js","alert","decrement_refcount","to_js_string","$2","unregister_raw_value","_emscripten_asm_const_ii","code","a0","_emscripten_asm_const_iii","a1","_emscripten_asm_const_i","_emscripten_asm_const_iiii","a2","STATIC_BUMP","tempDoublePtr","__emscripten_traverse_stack","callee","funcname","first","a","caller","_emscripten_get_callstack_js","flags","callstack","iThisFunc","lastIndexOf","iThisFunc2","iNextLine","emscripten_source_map","stack_args","lines","split","newFirefoxRe","RegExp","firefoxRe","chromeRe","line","jsSymbolName","file","lineno","column","parts","exec","cSymbolName","haveSourceMap","originalPositionFor","source","substring","__Unwind_Backtrace","trace","__Unwind_FindEnclosingFunction","__Unwind_GetIPInfo","___assert_fail","_emscripten_get_now","_emscripten_get_now_is_monotonic","dateNow","self","ERRNO_CODES","EPERM","ENOENT","ESRCH","EINTR","EIO","ENXIO","E2BIG","ENOEXEC","EBADF","ECHILD","EAGAIN","EWOULDBLOCK","ENOMEM","EACCES","EFAULT","ENOTBLK","EBUSY","EEXIST","EXDEV","ENODEV","ENOTDIR","EISDIR","EINVAL","ENFILE","EMFILE","ENOTTY","ETXTBSY","EFBIG","ENOSPC","ESPIPE","EROFS","EMLINK","EPIPE","EDOM","ERANGE","ENOMSG","EIDRM","ECHRNG","EL2NSYNC","EL3HLT","EL3RST","ELNRNG","EUNATCH","ENOCSI","EL2HLT","EDEADLK","ENOLCK","EBADE","EBADR","EXFULL","ENOANO","EBADRQC","EBADSLT","EDEADLOCK","EBFONT","ENOSTR","ENODATA","ETIME","ENOSR","ENONET","ENOPKG","EREMOTE","ENOLINK","EADV","ESRMNT","ECOMM","EPROTO","EMULTIHOP","EDOTDOT","EBADMSG","ENOTUNIQ","EBADFD","EREMCHG","ELIBACC","ELIBBAD","ELIBSCN","ELIBMAX","ELIBEXEC","ENOSYS","ENOTEMPTY","ENAMETOOLONG","ELOOP","EOPNOTSUPP","EPFNOSUPPORT","ECONNRESET","ENOBUFS","EAFNOSUPPORT","EPROTOTYPE","ENOTSOCK","ENOPROTOOPT","ESHUTDOWN","ECONNREFUSED","EADDRINUSE","ECONNABORTED","ENETUNREACH","ENETDOWN","ETIMEDOUT","EHOSTDOWN","EHOSTUNREACH","EINPROGRESS","EALREADY","EDESTADDRREQ","EMSGSIZE","EPROTONOSUPPORT","ESOCKTNOSUPPORT","EADDRNOTAVAIL","ENETRESET","EISCONN","ENOTCONN","ETOOMANYREFS","EUSERS","EDQUOT","ESTALE","ENOTSUP","ENOMEDIUM","EILSEQ","EOVERFLOW","ECANCELED","ENOTRECOVERABLE","EOWNERDEAD","ESTRPIPE","___setErrNo","_clock_gettime","clk_id","tp","now","Date","___clock_gettime","___cxa_allocate_exception","___cxa_find_matching_catch_2","___cxa_find_matching_catch","__ZSt18uncaught_exceptionv","uncaught_exception","EXCEPTIONS","last","caught","infos","deAdjust","adjusted","addRef","refcount","decRef","rethrown","destructor","___cxa_free_exception","clearRef","___resumeException","thrown","throwntype","typeArray","___cxa_throw","___gxx_personality_v0","___lock","___map_file","pathname","ERRNO_MESSAGES","0","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","122","123","125","130","131","PATH","splitPath","splitPathRe","normalizeArray","allowAboveRoot","up","normalize","path","isAbsolute","trailingSlash","filter","join","dirname","root","dir","basename","lastSlash","extname","paths","join2","resolvedPath","resolvedAbsolute","FS","cwd","TypeError","relative","from","to","trim","start","fromParts","toParts","samePartsLength","outputParts","concat","TTY","ttys","init","shutdown","register","dev","ops","input","registerDevice","stream_ops","stream","tty","node","rdev","ErrnoError","seekable","close","flush","offset","pos","get_char","bytesRead","timestamp","write","put_char","default_tty_ops","BUFSIZE","isPosixPlatform","platform","fd","stdin","usingDevice","fs","openSync","readSync","closeSync","prompt","readline","intArrayFromString","val","default_tty1_ops","MEMFS","ops_table","mount","createNode","mode","isBlkdev","isFIFO","getattr","node_ops","setattr","lookup","mknod","rename","unlink","rmdir","readdir","symlink","llseek","mmap","msync","link","readlink","chrdev","chrdev_stream_ops","isDir","contents","isFile","usedBytes","isLink","isChrdev","getFileDataAsRegularArray","getFileDataAsTypedArray","expandFileStorage","newCapacity","prevCapacity","CAPACITY_DOUBLING_MAX","oldContents","resizeFileStorage","newSize","attr","ino","nlink","uid","gid","atime","mtime","ctime","blksize","blocks","genericErrors","old_node","new_dir","new_name","new_node","lookupNode","entries","newname","oldpath","position","canOwn","whence","prot","allocated","byteOffset","mmapFlags","IDBFS","dbs","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","DB_VERSION","DB_STORE_NAME","syncfs","populate","getLocalSet","local","getRemoteSet","remote","src","dst","reconcile","getDB","req","db","onupgradeneeded","fileStore","target","transaction","objectStoreNames","contains","objectStore","createObjectStore","indexNames","createIndex","unique","onsuccess","this","preventDefault","isRealDir","toAbsolute","check","mountpoint","map","stat","pop","store","index","openKeyCursor","event","cursor","primaryKey","continue","loadLocalEntry","lookupPath","storeLocalEntry","entry","mkdir","writeFile","chmod","utime","removeLocalEntry","loadRemoteEntry","storeRemoteEntry","put","removeRemoteEntry","delete","total","create","keys","forEach","e2","remove","completed","done","errored","sort","reverse","NODEFS","isWindows","staticInit","match","flagsForNodeMap","1024","128","4096","512","bufferFrom","arrayBuffer","alloc","getMode","lstatSync","realPath","flagsForNode","newFlags","k","chmodSync","date","utimesSync","truncateSync","mkdirSync","writeFileSync","oldNode","newDir","newName","oldPath","newPath","renameSync","unlinkSync","rmdirSync","readdirSync","symlinkSync","readlinkSync","NODEJS_PATH","nfd","writeSync","fstatSync","WORKERFS","DIR_MODE","FILE_MODE","reader","FileReaderSync","createdParents","ensureParent","base","lastModifiedDate","obj","pack","files","getTime","chunk","ab","readAsArrayBuffer","mounts","devices","streams","nextInode","nameTable","currentPath","initialized","ignorePermissions","trackingDelegate","tracking","openFlags","READ","WRITE","filesystems","syncFSRequests","handleFSError","errno","defaults","follow_mount","recurse_count","current","current_path","islast","isMountpoint","mounted","follow","count","getPath","isRoot","hashName","parentid","hash","hashAddNode","name_next","hashRemoveNode","mayLookup","nodeName","FSNode","readMode","writeMode","defineProperties","isFolder","isDevice","destroyNode","isSocket","flagModes","rs","r+","w","wx","xw","w+","wx+","xw+","ax","xa","a+","ax+","xa+","modeStringToFlags","flagsToPermissionString","flag","perms","nodePermissions","mayCreate","mayDelete","isdir","mayOpen","MAX_OPEN_FDS","nextfd","fd_start","fd_end","getStream","createStream","FSStream","isRead","isWrite","isAppend","newStream","closeStream","device","getDevice","major","minor","makedev","ma","mi","getMounts","doCallback","pseudo","mountRoot","unmount","next","mkdirTree","dirs","mkdev","newpath","old_path","new_path","old_dir","old_dirname","new_dirname","old_name","message","dontFollow","lstat","lchmod","fchmod","chown","lchown","fchown","truncate","ftruncate","created","ungotten","readFiles","trackingFlags","isClosed","getdents","seeking","bytesWritten","munmap","ioctl","cmd","readFile","encoding","actualNumBytes","isView","chdir","createDefaultDirectories","createDefaultDevices","random_device","crypto","randomBuffer","getRandomValues","createDevice","createSpecialDirectories","createStandardStreams","stdout","stderr","ensureErrnoError","setErrno","writable","constructor","fflush","canRead","canWrite","joinPath","forceRelative","absolutePath","standardizePath","findObject","dontResolveLastLink","analyzePath","exists","parentExists","parentPath","parentObject","createFolder","createPath","part","createFile","properties","createDataFile","createLink","forceLoadFile","createLazyFile","LazyUint8Array","lengthKnown","chunks","chunkOffset","chunkSize","chunkNum","setDataGetter","cacheLength","header","datalength","Number","getResponseHeader","hasByteServing","usesGzip","doXHR","setRequestHeader","overrideMimeType","lazyArray","_length","_chunkSize","fn","createPreloadedFile","dontCreateFile","preFinish","Browser","fullname","processData","byteArray","finish","handled","plugin","asyncLoad","DB_NAME","location","saveFilesToDB","openRequest","ok","fail","putRequest","loadFilesFromDB","getRequest","SYSCALLS","DEFAULT_POLLMASK","mappings","umask","calculateAt","dirfd","dirstream","doStat","doMsync","addr","doMkdir","doMknod","doReadlink","bufsize","endChar","doAccess","amode","doDup","suggestFD","suggest","doReadv","iov","iovcnt","doWritev","varargs","getStr","getStreamFromFD","getSocketFromFD","socket","SOCKFS","getSocket","getSocketAddress","allowNull","addrp","addrlen","__read_sockaddr","DNS","lookup_addr","get64","low","high","getZero","___syscall10","which","___syscall140","offset_low","___syscall145","___syscall146","___syscall196","___syscall221","___syscall330","___syscall38","___syscall4","___syscall40","___syscall5","___syscall54","op","argp","___syscall6","___syscall63","___syscall91","_free","malloc","___unlock","_abort","_clock","_difftime","time1","time0","_dladdr","fname","__exit","_exit","_environ","___buildEnvironment","poolPtr","envPtr","MAX_ENV_VALUES","TOTAL_ENV_SIZE","called","ENV","strings","totalSize","ptrSize","_getenv","___tm_current","___tm_timezone","_gmtime_r","time","tmPtr","getUTCSeconds","getUTCMinutes","getUTCHours","getUTCDate","getUTCMonth","getUTCFullYear","getUTCDay","UTC","yday","_gmtime","_llvm_pow_f64","_llvm_trap","_tzname","_daylight","_timezone","_tzset","getTimezoneOffset","winter","summer","winterName","extractZone","summerName","winterNamePtr","summerNamePtr","toTimeString","_localtime_r","getSeconds","getMinutes","getHours","getDate","getMonth","getFullYear","getDay","summerOffset","winterOffset","zonePtr","_localtime","_longjmp","_emscripten_memcpy_big","dest","num","_mktime","guessedOffset","dstOffset","nonDstOffset","trueOffset","setTime","_pthread_cond_destroy","_pthread_cond_init","_pthread_condattr_destroy","_pthread_condattr_init","_pthread_condattr_setclock","PTHREAD_SPECIFIC","_pthread_getspecific","PTHREAD_SPECIFIC_NEXT_KEY","_pthread_key_create","_pthread_key_delete","_pthread_mutex_destroy","_pthread_mutex_init","_pthread_mutexattr_destroy","_pthread_mutexattr_init","_pthread_mutexattr_settype","_pthread_rwlock_rdlock","_pthread_rwlock_unlock","_pthread_rwlock_wrlock","_pthread_setspecific","__isLeapYear","year","__arraySum","sum","__MONTH_DAYS_LEAP","__MONTH_DAYS_REGULAR","__addDays","days","newDate","leap","currentMonth","daysInCurrentMonth","setDate","setMonth","setFullYear","_strftime","maxsize","format","tm","tm_zone","tm_sec","tm_min","tm_hour","tm_mday","tm_mon","tm_year","tm_wday","tm_yday","tm_isdst","tm_gmtoff","pattern","EXPANSION_RULES_1","%c","%D","%F","%h","%r","%R","%T","%x","%X","rule","WEEKDAYS","MONTHS","leadingSomething","digits","character","leadingNulls","compareByDay","date1","date2","sgn","compare","getFirstWeekStartDate","janFourth","getWeekBasedYear","thisDate","janFourthThisYear","janFourthNextYear","firstWeekStartThisYear","firstWeekStartNextYear","EXPANSION_RULES_2","%a","%A","%b","%B","%C","%d","%e","%g","%G","%H","%I","twelveHour","%j","%m","%M","%n","%p","%S","%t","%u","day","%U","janFirst","firstSunday","endDate","februaryFirstUntilEndMonth","firstSundayUntilEndJanuary","%V","daysDifference","%w","%W","firstMonday","firstMondayUntilEndJanuary","%y","%Y","%z","off","ahead","%Z","%%","bytes","_system","command","_time","performance","stringy","u8array","numBytesWritten","nullFunc_i","nullFunc_ii","nullFunc_iii","nullFunc_iiii","nullFunc_iiiii","nullFunc_ji","nullFunc_v","nullFunc_vi","nullFunc_vii","nullFunc_viii","nullFunc_viiii","nullFunc_viiiiiii","invoke_i","invoke_ii","invoke_iii","invoke_iiii","a3","invoke_iiiii","a4","invoke_ji","invoke_v","invoke_vi","invoke_vii","invoke_viii","invoke_viiii","invoke_viiiiiii","a5","a6","a7","asmGlobalArg","asmLibraryArg","asm","real____errno_location","real__execute_lua","real__fflush","real__free","real__htonl","real__htons","real__llvm_bswap_i16","real__llvm_bswap_i32","real__malloc","real__ntohs","real__pthread_mutex_lock","real__pthread_mutex_unlock","real__realloc","real__saveSetjmp","real__sbrk","real__testSetjmp","real_establishStackSpace","real_getTempRet0","real_setTempRet0","real_setThrew","real_stackAlloc","real_stackRestore","real_stackSave","initialStackTop","run","doRun","setTimeout","checkUnflushedContent","has","hasFS","exit","implicit","runCaller","abortDecorators","what","JSON","stringify","extra","decorator","ENVIRONMENT","Appvue_type_template_id_77c37c07_render","_vm","_h","$createElement","_c","_self","attrs","staticClass","_v","staticRenderFns","Editorvue_type_template_id_57912f4c_scoped_true_render","language","on","editorMounted","click","exeLua","Editorvue_type_template_id_57912f4c_scoped_true_staticRenderFns","Editorvue_type_script_lang_js","editor","layout","getValue","_this","Monaco","monaco_editor_forvue_default","components_Editorvue_type_script_lang_js","component","componentNormalizer","Editor","Outputvue_type_template_id_3bc037aa_scoped_true_render","tabindex","keydown","keypress","_l","char","class","color","_s","_e","Outputvue_type_template_id_3bc037aa_scoped_true_staticRenderFns","lua_LuaEngine","LuaEngine","classCallCheck","EventBus","vue_runtime_esm","scriptIndex","main_default","noFSInit","mod","promptres","ascii","$emit","_executeLua","executeLua","luastr","install","Vue","$root","_luaEngine","mixin","beforeCreate","$options","luaEngine","use","lua","Outputvue_type_script_lang_js","scrollHeight","components_Outputvue_type_script_lang_js","Output_component","Output","Appvue_type_script_lang_js","src_Appvue_type_script_lang_js","App_component","App","config","productionTip","render","h","$mount","_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_6_oneOf_1_2_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_lang_css__WEBPACK_IMPORTED_MODULE_0___default","_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_6_oneOf_1_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Editor_vue_vue_type_style_index_0_id_57912f4c_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0___default","_node_modules_mini_css_extract_plugin_dist_loader_js_node_modules_css_loader_index_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_7_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_7_oneOf_1_3_node_modules_vue_loader_lib_index_js_vue_loader_options_Output_vue_vue_type_style_index_0_id_3bc037aa_scoped_true_lang_scss__WEBPACK_IMPORTED_MODULE_0___default"],"mappings":"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","file":"js/app.b483936b.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t1: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([8,0]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","module.exports = (function(existingModule){\n      return {\n        // Returns a promise that resolves when the wasm runtime is initialized and ready for use\n        initialize: function(userDefinedModule) {\n          return new Promise((resolve, reject) => {\n            if (!userDefinedModule) {\n              userDefinedModule = {}\n            }\n            var Module = Object.assign({}, userDefinedModule, existingModule);\n            Module['onRuntimeInitialized'] = () => resolve(Module);\n            \n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(Module) { ..generated code.. }\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = typeof Module !== 'undefined' ? Module : {};\r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n// {{PRE_JSES}}\r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = {};\r\nvar key;\r\nfor (key in Module) {\r\n  if (Module.hasOwnProperty(key)) {\r\n    moduleOverrides[key] = Module[key];\r\n  }\r\n}\r\n\r\nModule['arguments'] = [];\r\nModule['thisProgram'] = './this.program';\r\nModule['quit'] = function(status, toThrow) {\r\n  throw toThrow;\r\n};\r\nModule['preRun'] = [];\r\nModule['postRun'] = [];\r\n\r\n// The environment setup code below is customized to use Module.\r\n// *** Environment setup code ***\r\nvar ENVIRONMENT_IS_WEB = false;\r\nvar ENVIRONMENT_IS_WORKER = false;\r\nvar ENVIRONMENT_IS_NODE = false;\r\nvar ENVIRONMENT_IS_SHELL = false;\r\n\r\n// Three configurations we can be running in:\r\n// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\r\n// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\r\n// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\r\n\r\nif (Module['ENVIRONMENT']) {\r\n  if (Module['ENVIRONMENT'] === 'WEB') {\r\n    ENVIRONMENT_IS_WEB = true;\r\n  } else if (Module['ENVIRONMENT'] === 'WORKER') {\r\n    ENVIRONMENT_IS_WORKER = true;\r\n  } else if (Module['ENVIRONMENT'] === 'NODE') {\r\n    ENVIRONMENT_IS_NODE = true;\r\n  } else if (Module['ENVIRONMENT'] === 'SHELL') {\r\n    ENVIRONMENT_IS_SHELL = true;\r\n  } else {\r\n    throw new Error('Module[\\'ENVIRONMENT\\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');\r\n  }\r\n} else {\r\n  ENVIRONMENT_IS_WEB = typeof window === 'object';\r\n  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\r\n  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\r\n  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n}\r\n\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  // Expose functionality in the same simple way that the shells work\r\n  // Note that we pollute the global namespace here, otherwise we break in node\r\n  var nodeFS;\r\n  var nodePath;\r\n\r\n  Module['read'] = function shell_read(filename, binary) {\r\n    var ret;\r\n      if (!nodeFS) nodeFS = require('fs');\r\n      if (!nodePath) nodePath = require('path');\r\n      filename = nodePath['normalize'](filename);\r\n      ret = nodeFS['readFileSync'](filename);\r\n    return binary ? ret : ret.toString();\r\n  };\r\n\r\n  Module['readBinary'] = function readBinary(filename) {\r\n    var ret = Module['read'](filename, true);\r\n    if (!ret.buffer) {\r\n      ret = new Uint8Array(ret);\r\n    }\r\n    assert(ret.buffer);\r\n    return ret;\r\n  };\r\n\r\n  if (process['argv'].length > 1) {\r\n    Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\r\n  }\r\n\r\n  Module['arguments'] = process['argv'].slice(2);\r\n\r\n  if (typeof module !== 'undefined') {\r\n    module['exports'] = Module;\r\n  }\r\n\r\n  process['on']('uncaughtException', function(ex) {\r\n    // suppress ExitStatus exceptions from showing an error\r\n    if (!(ex instanceof ExitStatus)) {\r\n      throw ex;\r\n    }\r\n  });\r\n  // Currently node will swallow unhandled rejections, but this behavior is\r\n  // deprecated, and in the future it will exit with error status.\r\n  process['on']('unhandledRejection', function(reason, p) {\r\n    Module['printErr']('node.js exiting due to unhandled promise rejection');\r\n    process['exit'](1);\r\n  });\r\n\r\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\r\n}\r\nelse if (ENVIRONMENT_IS_SHELL) {\r\n  if (typeof read != 'undefined') {\r\n    Module['read'] = function shell_read(f) {\r\n      return read(f);\r\n    };\r\n  }\r\n\r\n  Module['readBinary'] = function readBinary(f) {\r\n    var data;\r\n    if (typeof readbuffer === 'function') {\r\n      return new Uint8Array(readbuffer(f));\r\n    }\r\n    data = read(f, 'binary');\r\n    assert(typeof data === 'object');\r\n    return data;\r\n  };\r\n\r\n  if (typeof scriptArgs != 'undefined') {\r\n    Module['arguments'] = scriptArgs;\r\n  } else if (typeof arguments != 'undefined') {\r\n    Module['arguments'] = arguments;\r\n  }\r\n\r\n  if (typeof quit === 'function') {\r\n    Module['quit'] = function(status, toThrow) {\r\n      quit(status);\r\n    }\r\n  }\r\n}\r\nelse if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  Module['read'] = function shell_read(url) {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, false);\r\n      xhr.send(null);\r\n      return xhr.responseText;\r\n  };\r\n\r\n  if (ENVIRONMENT_IS_WORKER) {\r\n    Module['readBinary'] = function readBinary(url) {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, false);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.send(null);\r\n        return new Uint8Array(xhr.response);\r\n    };\r\n  }\r\n\r\n  Module['readAsync'] = function readAsync(url, onload, onerror) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'arraybuffer';\r\n    xhr.onload = function xhr_onload() {\r\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n        onload(xhr.response);\r\n        return;\r\n      }\r\n      onerror();\r\n    };\r\n    xhr.onerror = onerror;\r\n    xhr.send(null);\r\n  };\r\n\r\n  Module['setWindowTitle'] = function(title) { document.title = title };\r\n}\r\nelse {\r\n  // Unreachable because SHELL is dependent on the others\r\n  throw new Error('unknown runtime environment');\r\n}\r\n\r\n// console.log is checked first, as 'print' on the web will open a print dialogue\r\n// printErr is preferable to console.warn (works better in shells)\r\n// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\r\nModule['print'] = typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null);\r\nModule['printErr'] = typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || Module['print']);\r\n\r\n// *** Environment setup code ***\r\n\r\n// Closure helpers\r\nModule.print = Module['print'];\r\nModule.printErr = Module['printErr'];\r\n\r\n// Merge back in the overrides\r\nfor (key in moduleOverrides) {\r\n  if (moduleOverrides.hasOwnProperty(key)) {\r\n    Module[key] = moduleOverrides[key];\r\n  }\r\n}\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\r\nmoduleOverrides = undefined;\r\n\r\n\r\n\r\n// {{PREAMBLE_ADDITIONS}}\r\n\r\nvar STACK_ALIGN = 16;\r\n\r\n// stack management, and other functionality that is provided by the compiled code,\r\n// should not be used before it is ready\r\nstackSave = stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function() {\r\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\r\n};\r\n\r\nfunction staticAlloc(size) {\r\n  assert(!staticSealed);\r\n  var ret = STATICTOP;\r\n  STATICTOP = (STATICTOP + size + 15) & -16;\r\n  return ret;\r\n}\r\n\r\nfunction dynamicAlloc(size) {\r\n  assert(DYNAMICTOP_PTR);\r\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\r\n  var end = (ret + size + 15) & -16;\r\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\r\n  if (end >= TOTAL_MEMORY) {\r\n    var success = enlargeMemory();\r\n    if (!success) {\r\n      HEAP32[DYNAMICTOP_PTR>>2] = ret;\r\n      return 0;\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction alignMemory(size, factor) {\r\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\r\n  var ret = size = Math.ceil(size / factor) * factor;\r\n  return ret;\r\n}\r\n\r\nfunction getNativeTypeSize(type) {\r\n  switch (type) {\r\n    case 'i1': case 'i8': return 1;\r\n    case 'i16': return 2;\r\n    case 'i32': return 4;\r\n    case 'i64': return 8;\r\n    case 'float': return 4;\r\n    case 'double': return 8;\r\n    default: {\r\n      if (type[type.length-1] === '*') {\r\n        return 4; // A pointer\r\n      } else if (type[0] === 'i') {\r\n        var bits = parseInt(type.substr(1));\r\n        assert(bits % 8 === 0);\r\n        return bits / 8;\r\n      } else {\r\n        return 0;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction warnOnce(text) {\r\n  if (!warnOnce.shown) warnOnce.shown = {};\r\n  if (!warnOnce.shown[text]) {\r\n    warnOnce.shown[text] = 1;\r\n    Module.printErr(text);\r\n  }\r\n}\r\n\r\n\r\n\r\nvar jsCallStartIndex = 1;\r\nvar functionPointers = new Array(0);\r\n\r\n// 'sig' parameter is only used on LLVM wasm backend\r\nfunction addFunction(func, sig) {\r\n  if (typeof sig === 'undefined') {\r\n    Module.printErr('Warning: addFunction: Provide a wasm function signature ' +\r\n                    'string as a second argument');\r\n  }\r\n  var base = 0;\r\n  for (var i = base; i < base + 0; i++) {\r\n    if (!functionPointers[i]) {\r\n      functionPointers[i] = func;\r\n      return jsCallStartIndex + i;\r\n    }\r\n  }\r\n  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\r\n}\r\n\r\nfunction removeFunction(index) {\r\n  functionPointers[index-jsCallStartIndex] = null;\r\n}\r\n\r\nvar funcWrappers = {};\r\n\r\nfunction getFuncWrapper(func, sig) {\r\n  if (!func) return; // on null pointer, return undefined\r\n  assert(sig);\r\n  if (!funcWrappers[sig]) {\r\n    funcWrappers[sig] = {};\r\n  }\r\n  var sigCache = funcWrappers[sig];\r\n  if (!sigCache[func]) {\r\n    // optimize away arguments usage in common cases\r\n    if (sig.length === 1) {\r\n      sigCache[func] = function dynCall_wrapper() {\r\n        return dynCall(sig, func);\r\n      };\r\n    } else if (sig.length === 2) {\r\n      sigCache[func] = function dynCall_wrapper(arg) {\r\n        return dynCall(sig, func, [arg]);\r\n      };\r\n    } else {\r\n      // general case\r\n      sigCache[func] = function dynCall_wrapper() {\r\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\r\n      };\r\n    }\r\n  }\r\n  return sigCache[func];\r\n}\r\n\r\n\r\nfunction makeBigInt(low, high, unsigned) {\r\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\r\n}\r\n\r\nfunction dynCall(sig, ptr, args) {\r\n  if (args && args.length) {\r\n    assert(args.length == sig.length-1);\r\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\r\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\r\n  } else {\r\n    assert(sig.length == 1);\r\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\r\n    return Module['dynCall_' + sig].call(null, ptr);\r\n  }\r\n}\r\n\r\n\r\nfunction getCompilerSetting(name) {\r\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\r\n}\r\n\r\nvar Runtime = {\r\n  // FIXME backwards compatibility layer for ports. Support some Runtime.*\r\n  //       for now, fix it there, then remove it from here. That way we\r\n  //       can minimize any period of breakage.\r\n  dynCall: dynCall, // for SDL2 port\r\n  // helpful errors\r\n  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\r\n  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\r\n  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\r\n};\r\n\r\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\r\n// Above 0 is static memory, starting with globals.\r\n// Then the stack.\r\n// Then 'dynamic' memory for sbrk.\r\nvar GLOBAL_BASE = 1024;\r\n\r\n\r\n\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\n\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\nvar ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\r\nvar EXITSTATUS = 0;\r\n\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    abort('Assertion failed: ' + text);\r\n  }\r\n}\r\n\r\nvar globalScope = this;\r\n\r\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\r\nfunction getCFunc(ident) {\r\n  var func = Module['_' + ident]; // closure exported function\r\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\r\n  return func;\r\n}\r\n\r\nvar JSfuncs = {\r\n  // Helpers for cwrap -- it can't refer to Runtime directly because it might\r\n  // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\r\n  // out what the minified function name is.\r\n  'stackSave': function() {\r\n    stackSave()\r\n  },\r\n  'stackRestore': function() {\r\n    stackRestore()\r\n  },\r\n  // type conversion from js to c\r\n  'arrayToC' : function(arr) {\r\n    var ret = stackAlloc(arr.length);\r\n    writeArrayToMemory(arr, ret);\r\n    return ret;\r\n  },\r\n  'stringToC' : function(str) {\r\n    var ret = 0;\r\n    if (str !== null && str !== undefined && str !== 0) { // null string\r\n      // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\r\n      var len = (str.length << 2) + 1;\r\n      ret = stackAlloc(len);\r\n      stringToUTF8(str, ret, len);\r\n    }\r\n    return ret;\r\n  }\r\n};\r\n\r\n// For fast lookup of conversion functions\r\nvar toC = {\r\n  'string': JSfuncs['stringToC'], 'array': JSfuncs['arrayToC']\r\n};\r\n\r\n// C calling interface.\r\nfunction ccall (ident, returnType, argTypes, args, opts) {\r\n  var func = getCFunc(ident);\r\n  var cArgs = [];\r\n  var stack = 0;\r\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\r\n  if (args) {\r\n    for (var i = 0; i < args.length; i++) {\r\n      var converter = toC[argTypes[i]];\r\n      if (converter) {\r\n        if (stack === 0) stack = stackSave();\r\n        cArgs[i] = converter(args[i]);\r\n      } else {\r\n        cArgs[i] = args[i];\r\n      }\r\n    }\r\n  }\r\n  var ret = func.apply(null, cArgs);\r\n  if (returnType === 'string') ret = Pointer_stringify(ret);\r\n  else if (returnType === 'boolean') ret = Boolean(ret);\r\n  if (stack !== 0) {\r\n    stackRestore(stack);\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction cwrap (ident, returnType, argTypes) {\r\n  argTypes = argTypes || [];\r\n  var cfunc = getCFunc(ident);\r\n  // When the function takes numbers and returns a number, we can just return\r\n  // the original function\r\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\r\n  var numericRet = returnType !== 'string';\r\n  if (numericRet && numericArgs) {\r\n    return cfunc;\r\n  }\r\n  return function() {\r\n    return ccall(ident, returnType, argTypes, arguments);\r\n  }\r\n}\r\n\r\n/** @type {function(number, number, string, boolean=)} */\r\nfunction setValue(ptr, value, type, noSafe) {\r\n  type = type || 'i8';\r\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\r\n    switch(type) {\r\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\r\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\r\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\r\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\r\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\r\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\r\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\r\n      default: abort('invalid type for setValue: ' + type);\r\n    }\r\n}\r\n\r\n/** @type {function(number, string, boolean=)} */\r\nfunction getValue(ptr, type, noSafe) {\r\n  type = type || 'i8';\r\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\r\n    switch(type) {\r\n      case 'i1': return HEAP8[((ptr)>>0)];\r\n      case 'i8': return HEAP8[((ptr)>>0)];\r\n      case 'i16': return HEAP16[((ptr)>>1)];\r\n      case 'i32': return HEAP32[((ptr)>>2)];\r\n      case 'i64': return HEAP32[((ptr)>>2)];\r\n      case 'float': return HEAPF32[((ptr)>>2)];\r\n      case 'double': return HEAPF64[((ptr)>>3)];\r\n      default: abort('invalid type for getValue: ' + type);\r\n    }\r\n  return null;\r\n}\r\n\r\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\r\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\r\nvar ALLOC_STATIC = 2; // Cannot be freed\r\nvar ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\r\nvar ALLOC_NONE = 4; // Do not allocate\r\n\r\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\r\n//             is a little tricky (see docs right below). The reason is that it is optimized\r\n//             for multiple syntaxes to save space in generated code. So you should\r\n//             normally not use allocate(), and instead allocate memory using _malloc(),\r\n//             initialize it with setValue(), and so forth.\r\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\r\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\r\n//        affect this!)\r\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\r\n//         or a single type which is used for the entire block. This only matters if there\r\n//         is initial data - if @slab is a number, then this does not matter at all and is\r\n//         ignored.\r\n// @allocator: How to allocate memory, see ALLOC_*\r\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\r\nfunction allocate(slab, types, allocator, ptr) {\r\n  var zeroinit, size;\r\n  if (typeof slab === 'number') {\r\n    zeroinit = true;\r\n    size = slab;\r\n  } else {\r\n    zeroinit = false;\r\n    size = slab.length;\r\n  }\r\n\r\n  var singleType = typeof types === 'string' ? types : null;\r\n\r\n  var ret;\r\n  if (allocator == ALLOC_NONE) {\r\n    ret = ptr;\r\n  } else {\r\n    ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\r\n  }\r\n\r\n  if (zeroinit) {\r\n    var stop;\r\n    ptr = ret;\r\n    assert((ret & 3) == 0);\r\n    stop = ret + (size & ~3);\r\n    for (; ptr < stop; ptr += 4) {\r\n      HEAP32[((ptr)>>2)]=0;\r\n    }\r\n    stop = ret + size;\r\n    while (ptr < stop) {\r\n      HEAP8[((ptr++)>>0)]=0;\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  if (singleType === 'i8') {\r\n    if (slab.subarray || slab.slice) {\r\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\r\n    } else {\r\n      HEAPU8.set(new Uint8Array(slab), ret);\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  var i = 0, type, typeSize, previousType;\r\n  while (i < size) {\r\n    var curr = slab[i];\r\n\r\n    type = singleType || types[i];\r\n    if (type === 0) {\r\n      i++;\r\n      continue;\r\n    }\r\n    assert(type, 'Must know what type to store in allocate!');\r\n\r\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\r\n\r\n    setValue(ret+i, curr, type);\r\n\r\n    // no need to look up size unless type changes, so cache it\r\n    if (previousType !== type) {\r\n      typeSize = getNativeTypeSize(type);\r\n      previousType = type;\r\n    }\r\n    i += typeSize;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\r\nfunction getMemory(size) {\r\n  if (!staticSealed) return staticAlloc(size);\r\n  if (!runtimeInitialized) return dynamicAlloc(size);\r\n  return _malloc(size);\r\n}\r\n\r\n/** @type {function(number, number=)} */\r\nfunction Pointer_stringify(ptr, length) {\r\n  if (length === 0 || !ptr) return '';\r\n  // TODO: use TextDecoder\r\n  // Find the length, and check for UTF while doing so\r\n  var hasUtf = 0;\r\n  var t;\r\n  var i = 0;\r\n  while (1) {\r\n    assert(ptr + i < TOTAL_MEMORY);\r\n    t = HEAPU8[(((ptr)+(i))>>0)];\r\n    hasUtf |= t;\r\n    if (t == 0 && !length) break;\r\n    i++;\r\n    if (length && i == length) break;\r\n  }\r\n  if (!length) length = i;\r\n\r\n  var ret = '';\r\n\r\n  if (hasUtf < 128) {\r\n    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\r\n    var curr;\r\n    while (length > 0) {\r\n      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\r\n      ret = ret ? ret + curr : curr;\r\n      ptr += MAX_CHUNK;\r\n      length -= MAX_CHUNK;\r\n    }\r\n    return ret;\r\n  }\r\n  return UTF8ToString(ptr);\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nfunction AsciiToString(ptr) {\r\n  var str = '';\r\n  while (1) {\r\n    var ch = HEAP8[((ptr++)>>0)];\r\n    if (!ch) return str;\r\n    str += String.fromCharCode(ch);\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\r\n\r\nfunction stringToAscii(str, outPtr) {\r\n  return writeAsciiToMemory(str, outPtr, false);\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\r\nfunction UTF8ArrayToString(u8Array, idx) {\r\n  var endPtr = idx;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  while (u8Array[endPtr]) ++endPtr;\r\n\r\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\r\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\r\n  } else {\r\n    var u0, u1, u2, u3, u4, u5;\r\n\r\n    var str = '';\r\n    while (1) {\r\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\r\n      u0 = u8Array[idx++];\r\n      if (!u0) return str;\r\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n      u1 = u8Array[idx++] & 63;\r\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n      u2 = u8Array[idx++] & 63;\r\n      if ((u0 & 0xF0) == 0xE0) {\r\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n      } else {\r\n        u3 = u8Array[idx++] & 63;\r\n        if ((u0 & 0xF8) == 0xF0) {\r\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\r\n        } else {\r\n          u4 = u8Array[idx++] & 63;\r\n          if ((u0 & 0xFC) == 0xF8) {\r\n            u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\r\n          } else {\r\n            u5 = u8Array[idx++] & 63;\r\n            u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\r\n          }\r\n        }\r\n      }\r\n      if (u0 < 0x10000) {\r\n        str += String.fromCharCode(u0);\r\n      } else {\r\n        var ch = u0 - 0x10000;\r\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nfunction UTF8ToString(ptr) {\r\n  return UTF8ArrayToString(HEAPU8,ptr);\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\r\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\r\n//   outIdx: The starting offset in the array to begin the copying.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\r\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\r\n    return 0;\r\n\r\n  var startIdx = outIdx;\r\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    if (u <= 0x7F) {\r\n      if (outIdx >= endIdx) break;\r\n      outU8Array[outIdx++] = u;\r\n    } else if (u <= 0x7FF) {\r\n      if (outIdx + 1 >= endIdx) break;\r\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    } else if (u <= 0xFFFF) {\r\n      if (outIdx + 2 >= endIdx) break;\r\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    } else if (u <= 0x1FFFFF) {\r\n      if (outIdx + 3 >= endIdx) break;\r\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    } else if (u <= 0x3FFFFFF) {\r\n      if (outIdx + 4 >= endIdx) break;\r\n      outU8Array[outIdx++] = 0xF8 | (u >> 24);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    } else {\r\n      if (outIdx + 5 >= endIdx) break;\r\n      outU8Array[outIdx++] = 0xFC | (u >> 30);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n      outU8Array[outIdx++] = 0x80 | (u & 63);\r\n    }\r\n  }\r\n  // Null-terminate the pointer to the buffer.\r\n  outU8Array[outIdx] = 0;\r\n  return outIdx - startIdx;\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\r\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF8(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var u = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    if (u <= 0x7F) {\r\n      ++len;\r\n    } else if (u <= 0x7FF) {\r\n      len += 2;\r\n    } else if (u <= 0xFFFF) {\r\n      len += 3;\r\n    } else if (u <= 0x1FFFFF) {\r\n      len += 4;\r\n    } else if (u <= 0x3FFFFFF) {\r\n      len += 5;\r\n    } else {\r\n      len += 6;\r\n    }\r\n  }\r\n  return len;\r\n}\r\n\r\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\r\n// a copy of that string as a Javascript String object.\r\n\r\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\r\nfunction UTF16ToString(ptr) {\r\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\r\n  var endPtr = ptr;\r\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\r\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\r\n  var idx = endPtr >> 1;\r\n  while (HEAP16[idx]) ++idx;\r\n  endPtr = idx << 1;\r\n\r\n  if (endPtr - ptr > 32 && UTF16Decoder) {\r\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n  } else {\r\n    var i = 0;\r\n\r\n    var str = '';\r\n    while (1) {\r\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\r\n      if (codeUnit == 0) return str;\r\n      ++i;\r\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\r\n      str += String.fromCharCode(codeUnit);\r\n    }\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\r\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\r\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 2) return 0;\r\n  maxBytesToWrite -= 2; // Null terminator.\r\n  var startPtr = outPtr;\r\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\r\n  for (var i = 0; i < numCharsToWrite; ++i) {\r\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    HEAP16[((outPtr)>>1)]=codeUnit;\r\n    outPtr += 2;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP16[((outPtr)>>1)]=0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF16(str) {\r\n  return str.length*2;\r\n}\r\n\r\nfunction UTF32ToString(ptr) {\r\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\r\n  var i = 0;\r\n\r\n  var str = '';\r\n  while (1) {\r\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\r\n    if (utf32 == 0)\r\n      return str;\r\n    ++i;\r\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    if (utf32 >= 0x10000) {\r\n      var ch = utf32 - 0x10000;\r\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n    } else {\r\n      str += String.fromCharCode(utf32);\r\n    }\r\n  }\r\n}\r\n\r\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\r\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\r\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\r\n// Parameters:\r\n//   str: the Javascript string to copy.\r\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\r\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\r\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\r\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\r\n// Returns the number of bytes written, EXCLUDING the null terminator.\r\n\r\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\r\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\r\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n  if (maxBytesToWrite === undefined) {\r\n    maxBytesToWrite = 0x7FFFFFFF;\r\n  }\r\n  if (maxBytesToWrite < 4) return 0;\r\n  var startPtr = outPtr;\r\n  var endPtr = startPtr + maxBytesToWrite - 4;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\r\n      var trailSurrogate = str.charCodeAt(++i);\r\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\r\n    }\r\n    HEAP32[((outPtr)>>2)]=codeUnit;\r\n    outPtr += 4;\r\n    if (outPtr + 4 > endPtr) break;\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  HEAP32[((outPtr)>>2)]=0;\r\n  return outPtr - startPtr;\r\n}\r\n\r\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\r\n\r\nfunction lengthBytesUTF32(str) {\r\n  var len = 0;\r\n  for (var i = 0; i < str.length; ++i) {\r\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n    var codeUnit = str.charCodeAt(i);\r\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n    len += 4;\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n// Allocate heap space for a JS string, and write it there.\r\n// It is the responsibility of the caller to free() that memory.\r\nfunction allocateUTF8(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = _malloc(size);\r\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\n// Allocate stack space for a JS string, and write it there.\r\nfunction allocateUTF8OnStack(str) {\r\n  var size = lengthBytesUTF8(str) + 1;\r\n  var ret = stackAlloc(size);\r\n  stringToUTF8Array(str, HEAP8, ret, size);\r\n  return ret;\r\n}\r\n\r\nfunction demangle(func) {\r\n  warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\r\n  return func;\r\n}\r\n\r\nfunction demangleAll(text) {\r\n  var regex =\r\n    /__Z[\\w\\d_]+/g;\r\n  return text.replace(regex,\r\n    function(x) {\r\n      var y = demangle(x);\r\n      return x === y ? x : (x + ' [' + y + ']');\r\n    });\r\n}\r\n\r\nfunction jsStackTrace() {\r\n  var err = new Error();\r\n  if (!err.stack) {\r\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\r\n    // so try that as a special-case.\r\n    try {\r\n      throw new Error(0);\r\n    } catch(e) {\r\n      err = e;\r\n    }\r\n    if (!err.stack) {\r\n      return '(no stack trace available)';\r\n    }\r\n  }\r\n  return err.stack.toString();\r\n}\r\n\r\nfunction stackTrace() {\r\n  var js = jsStackTrace();\r\n  if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\r\n  return demangleAll(js);\r\n}\r\n\r\n// Memory management\r\n\r\nvar PAGE_SIZE = 16384;\r\nvar WASM_PAGE_SIZE = 65536;\r\nvar ASMJS_PAGE_SIZE = 16777216;\r\nvar MIN_TOTAL_MEMORY = 16777216;\r\n\r\nfunction alignUp(x, multiple) {\r\n  if (x % multiple > 0) {\r\n    x += multiple - (x % multiple);\r\n  }\r\n  return x;\r\n}\r\n\r\nvar HEAP,\r\n/** @type {ArrayBuffer} */\r\n  buffer,\r\n/** @type {Int8Array} */\r\n  HEAP8,\r\n/** @type {Uint8Array} */\r\n  HEAPU8,\r\n/** @type {Int16Array} */\r\n  HEAP16,\r\n/** @type {Uint16Array} */\r\n  HEAPU16,\r\n/** @type {Int32Array} */\r\n  HEAP32,\r\n/** @type {Uint32Array} */\r\n  HEAPU32,\r\n/** @type {Float32Array} */\r\n  HEAPF32,\r\n/** @type {Float64Array} */\r\n  HEAPF64;\r\n\r\nfunction updateGlobalBuffer(buf) {\r\n  Module['buffer'] = buffer = buf;\r\n}\r\n\r\nfunction updateGlobalBufferViews() {\r\n  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\r\n  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\r\n  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\r\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\r\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\r\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\r\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\r\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\r\n}\r\n\r\nvar STATIC_BASE, STATICTOP, staticSealed; // static area\r\nvar STACK_BASE, STACKTOP, STACK_MAX; // stack area\r\nvar DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\r\n\r\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\r\n  staticSealed = false;\r\n\r\n\r\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\nfunction writeStackCookie() {\r\n  assert((STACK_MAX & 3) == 0);\r\n  HEAPU32[(STACK_MAX >> 2)-1] = 0x02135467;\r\n  HEAPU32[(STACK_MAX >> 2)-2] = 0x89BACDFE;\r\n}\r\n\r\nfunction checkStackCookie() {\r\n  if (HEAPU32[(STACK_MAX >> 2)-1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2)-2] != 0x89BACDFE) {\r\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2)-2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2)-1].toString(16));\r\n  }\r\n  // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.\r\n  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\r\n}\r\n\r\nfunction abortStackOverflow(allocSize) {\r\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\r\n}\r\n\r\nfunction abortOnCannotGrowMemory() {\r\n  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\r\n}\r\n\r\n\r\nfunction enlargeMemory() {\r\n  abortOnCannotGrowMemory();\r\n}\r\n\r\n\r\nvar TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\r\nvar TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\r\nif (TOTAL_MEMORY < TOTAL_STACK) Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\r\n\r\n// Initialize the runtime's memory\r\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\r\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,\r\n       'JS engine does not provide full typed array support');\r\n\r\n\r\n\r\n// Use a provided buffer, if there is one, or else allocate a new one\r\nif (Module['buffer']) {\r\n  buffer = Module['buffer'];\r\n  assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\r\n} else {\r\n  // Use a WebAssembly memory where available\r\n  if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {\r\n    assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\r\n    Module['wasmMemory'] = new WebAssembly.Memory({ 'initial': TOTAL_MEMORY / WASM_PAGE_SIZE, 'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE });\r\n    buffer = Module['wasmMemory'].buffer;\r\n  } else\r\n  {\r\n    buffer = new ArrayBuffer(TOTAL_MEMORY);\r\n  }\r\n  assert(buffer.byteLength === TOTAL_MEMORY);\r\n  Module['buffer'] = buffer;\r\n}\r\nupdateGlobalBufferViews();\r\n\r\n\r\nfunction getTotalMemory() {\r\n  return TOTAL_MEMORY;\r\n}\r\n\r\n// Endianness check (note: assumes compiler arch was little-endian)\r\n  HEAP32[0] = 0x63736d65; /* 'emsc' */\r\nHEAP16[1] = 0x6373;\r\nif (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\r\n\r\nfunction callRuntimeCallbacks(callbacks) {\r\n  while(callbacks.length > 0) {\r\n    var callback = callbacks.shift();\r\n    if (typeof callback == 'function') {\r\n      callback();\r\n      continue;\r\n    }\r\n    var func = callback.func;\r\n    if (typeof func === 'number') {\r\n      if (callback.arg === undefined) {\r\n        Module['dynCall_v'](func);\r\n      } else {\r\n        Module['dynCall_vi'](func, callback.arg);\r\n      }\r\n    } else {\r\n      func(callback.arg === undefined ? null : callback.arg);\r\n    }\r\n  }\r\n}\r\n\r\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\r\nvar __ATINIT__    = []; // functions called during startup\r\nvar __ATMAIN__    = []; // functions called when main() is to be run\r\nvar __ATEXIT__    = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the runtime has exited\r\n\r\nvar runtimeInitialized = false;\r\nvar runtimeExited = false;\r\n\r\n\r\nfunction preRun() {\r\n  // compatibility - merge in anything from Module['preRun'] at this time\r\n  if (Module['preRun']) {\r\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\r\n    while (Module['preRun'].length) {\r\n      addOnPreRun(Module['preRun'].shift());\r\n    }\r\n  }\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction ensureInitRuntime() {\r\n  checkStackCookie();\r\n  if (runtimeInitialized) return;\r\n  runtimeInitialized = true;\r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction preMain() {\r\n  checkStackCookie();\r\n  callRuntimeCallbacks(__ATMAIN__);\r\n}\r\n\r\nfunction exitRuntime() {\r\n  checkStackCookie();\r\n  callRuntimeCallbacks(__ATEXIT__);\r\n  runtimeExited = true;\r\n}\r\n\r\nfunction postRun() {\r\n  checkStackCookie();\r\n  // compatibility - merge in anything from Module['postRun'] at this time\r\n  if (Module['postRun']) {\r\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\r\n    while (Module['postRun'].length) {\r\n      addOnPostRun(Module['postRun'].shift());\r\n    }\r\n  }\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnPreMain(cb) {\r\n  __ATMAIN__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n  __ATEXIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\n// Deprecated: This function should not be called because it is unsafe and does not provide\r\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\r\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\r\n// to be secure from out of bounds writes.\r\n/** @deprecated */\r\nfunction writeStringToMemory(string, buffer, dontAddNull) {\r\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\r\n\r\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\r\n  if (dontAddNull) {\r\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\r\n    // character that existed at the location where the null will be placed, and restore\r\n    // that after the write (below).\r\n    end = buffer + lengthBytesUTF8(string);\r\n    lastChar = HEAP8[end];\r\n  }\r\n  stringToUTF8(string, buffer, Infinity);\r\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\r\n}\r\n\r\nfunction writeArrayToMemory(array, buffer) {\r\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\r\n  HEAP8.set(array, buffer);\r\n}\r\n\r\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\r\n  for (var i = 0; i < str.length; ++i) {\r\n    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);\r\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\r\n  }\r\n  // Null-terminate the pointer to the HEAP.\r\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\r\n}\r\n\r\nfunction unSign(value, bits, ignore) {\r\n  if (value >= 0) {\r\n    return value;\r\n  }\r\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\r\n                    : Math.pow(2, bits)         + value;\r\n}\r\nfunction reSign(value, bits, ignore) {\r\n  if (value <= 0) {\r\n    return value;\r\n  }\r\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\r\n                        : Math.pow(2, bits-1);\r\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\r\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\r\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\r\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\r\n  }\r\n  return value;\r\n}\r\n\r\nassert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');\r\n\r\nvar Math_abs = Math.abs;\r\nvar Math_cos = Math.cos;\r\nvar Math_sin = Math.sin;\r\nvar Math_tan = Math.tan;\r\nvar Math_acos = Math.acos;\r\nvar Math_asin = Math.asin;\r\nvar Math_atan = Math.atan;\r\nvar Math_atan2 = Math.atan2;\r\nvar Math_exp = Math.exp;\r\nvar Math_log = Math.log;\r\nvar Math_sqrt = Math.sqrt;\r\nvar Math_ceil = Math.ceil;\r\nvar Math_floor = Math.floor;\r\nvar Math_pow = Math.pow;\r\nvar Math_imul = Math.imul;\r\nvar Math_fround = Math.fround;\r\nvar Math_round = Math.round;\r\nvar Math_min = Math.min;\r\nvar Math_max = Math.max;\r\nvar Math_clz32 = Math.clz32;\r\nvar Math_trunc = Math.trunc;\r\n\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// PRE_RUN_ADDITIONS (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar runDependencyWatcher = null;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\nvar runDependencyTracking = {};\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  var orig = id;\r\n  while (1) {\r\n    if (!runDependencyTracking[id]) return id;\r\n    id = orig + Math.random();\r\n  }\r\n  return id;\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n  if (id) {\r\n    assert(!runDependencyTracking[id]);\r\n    runDependencyTracking[id] = 1;\r\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\r\n      // Check for missing dependencies every few seconds\r\n      runDependencyWatcher = setInterval(function() {\r\n        if (ABORT) {\r\n          clearInterval(runDependencyWatcher);\r\n          runDependencyWatcher = null;\r\n          return;\r\n        }\r\n        var shown = false;\r\n        for (var dep in runDependencyTracking) {\r\n          if (!shown) {\r\n            shown = true;\r\n            Module.printErr('still waiting on run dependencies:');\r\n          }\r\n          Module.printErr('dependency: ' + dep);\r\n        }\r\n        if (shown) {\r\n          Module.printErr('(end of list)');\r\n        }\r\n      }, 10000);\r\n    }\r\n  } else {\r\n    Module.printErr('warning: run dependency added without ID');\r\n  }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n  if (Module['monitorRunDependencies']) {\r\n    Module['monitorRunDependencies'](runDependencies);\r\n  }\r\n  if (id) {\r\n    assert(runDependencyTracking[id]);\r\n    delete runDependencyTracking[id];\r\n  } else {\r\n    Module.printErr('warning: run dependency removed without ID');\r\n  }\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\nModule[\"preloadedImages\"] = {}; // maps url to image data\r\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\r\n\r\n\r\n\r\nvar memoryInitializer = null;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n// Indicates whether filename is a base64 data URI.\r\nfunction isDataURI(filename) {\r\n  return String.prototype.startsWith ?\r\n      filename.startsWith(dataURIPrefix) :\r\n      filename.indexOf(dataURIPrefix) === 0;\r\n}\r\n\r\n\r\n\r\n\r\nfunction integrateWasmJS() {\r\n  // wasm.js has several methods for creating the compiled code module here:\r\n  //  * 'native-wasm' : use native WebAssembly support in the browser\r\n  //  * 'interpret-s-expr': load s-expression code from a .wast and interpret\r\n  //  * 'interpret-binary': load binary wasm and interpret\r\n  //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret\r\n  //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)\r\n  // The method is set at compile time (BINARYEN_METHOD)\r\n  // The method can be a comma-separated list, in which case, we will try the\r\n  // options one by one. Some of them can fail gracefully, and then we can try\r\n  // the next.\r\n\r\n  // inputs\r\n\r\n  var method = 'native-wasm';\r\n\r\n  var wasmTextFile = 'rust_lua.wast';\r\n  var wasmBinaryFile = 'rust_lua.wasm';\r\n  var asmjsCodeFile = 'rust_lua.temp.asm.js';\r\n\r\n  if (typeof Module['locateFile'] === 'function') {\r\n    if (!isDataURI(wasmTextFile)) {\r\n      wasmTextFile = Module['locateFile'](wasmTextFile);\r\n    }\r\n    if (!isDataURI(wasmBinaryFile)) {\r\n      wasmBinaryFile = Module['locateFile'](wasmBinaryFile);\r\n    }\r\n    if (!isDataURI(asmjsCodeFile)) {\r\n      asmjsCodeFile = Module['locateFile'](asmjsCodeFile);\r\n    }\r\n  }\r\n\r\n  // utilities\r\n\r\n  var wasmPageSize = 64*1024;\r\n\r\n  var info = {\r\n    'global': null,\r\n    'env': null,\r\n    'asm2wasm': { // special asm2wasm imports\r\n      \"f64-rem\": function(x, y) {\r\n        return x % y;\r\n      },\r\n      \"debugger\": function() {\r\n        debugger;\r\n      }\r\n    },\r\n    'parent': Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\r\n  };\r\n\r\n  var exports = null;\r\n\r\n\r\n  function mergeMemory(newBuffer) {\r\n    // The wasm instance creates its memory. But static init code might have written to\r\n    // buffer already, including the mem init file, and we must copy it over in a proper merge.\r\n    // TODO: avoid this copy, by avoiding such static init writes\r\n    // TODO: in shorter term, just copy up to the last static init write\r\n    var oldBuffer = Module['buffer'];\r\n    if (newBuffer.byteLength < oldBuffer.byteLength) {\r\n      Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\r\n    }\r\n    var oldView = new Int8Array(oldBuffer);\r\n    var newView = new Int8Array(newBuffer);\r\n\r\n\r\n    newView.set(oldView);\r\n    updateGlobalBuffer(newBuffer);\r\n    updateGlobalBufferViews();\r\n  }\r\n\r\n  function fixImports(imports) {\r\n    return imports;\r\n  }\r\n\r\n  function getBinary() {\r\n    try {\r\n      if (Module['wasmBinary']) {\r\n        return new Uint8Array(Module['wasmBinary']);\r\n      }\r\n      if (Module['readBinary']) {\r\n        return Module['readBinary'](wasmBinaryFile);\r\n      } else {\r\n        throw \"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)\";\r\n      }\r\n    }\r\n    catch (err) {\r\n      abort(err);\r\n    }\r\n  }\r\n\r\n  function getBinaryPromise() {\r\n    // if we don't have the binary yet, and have the Fetch api, use that\r\n    // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\r\n    if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\r\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\r\n        if (!response['ok']) {\r\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\r\n        }\r\n        return response['arrayBuffer']();\r\n      }).catch(function () {\r\n        return getBinary();\r\n      });\r\n    }\r\n    // Otherwise, getBinary should be able to get it synchronously\r\n    return new Promise(function(resolve, reject) {\r\n      resolve(getBinary());\r\n    });\r\n  }\r\n\r\n  // do-method functions\r\n\r\n\r\n  function doNativeWasm(global, env, providedBuffer) {\r\n    if (typeof WebAssembly !== 'object') {\r\n      Module['printErr']('no native wasm support detected');\r\n      return false;\r\n    }\r\n    // prepare memory import\r\n    if (!(Module['wasmMemory'] instanceof WebAssembly.Memory)) {\r\n      Module['printErr']('no native wasm Memory in use');\r\n      return false;\r\n    }\r\n    env['memory'] = Module['wasmMemory'];\r\n    // Load the wasm module and create an instance of using native support in the JS engine.\r\n    info['global'] = {\r\n      'NaN': NaN,\r\n      'Infinity': Infinity\r\n    };\r\n    info['global.Math'] = Math;\r\n    info['env'] = env;\r\n    // handle a generated wasm instance, receiving its exports and\r\n    // performing other necessary setup\r\n    function receiveInstance(instance, module) {\r\n      exports = instance.exports;\r\n      if (exports.memory) mergeMemory(exports.memory);\r\n      Module['asm'] = exports;\r\n      Module[\"usingWasm\"] = true;\r\n      removeRunDependency('wasm-instantiate');\r\n    }\r\n    addRunDependency('wasm-instantiate');\r\n\r\n    // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n    // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\r\n    // to any other async startup actions they are performing.\r\n    if (Module['instantiateWasm']) {\r\n      try {\r\n        return Module['instantiateWasm'](info, receiveInstance);\r\n      } catch(e) {\r\n        Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Async compilation can be confusing when an error on the page overwrites Module\r\n    // (for example, if the order of elements is wrong, and the one defining Module is\r\n    // later), so we save Module and check it later.\r\n    var trueModule = Module;\r\n    function receiveInstantiatedSource(output) {\r\n      // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\r\n      // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n      assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\r\n      trueModule = null;\r\n      receiveInstance(output['instance'], output['module']);\r\n    }\r\n    function instantiateArrayBuffer(receiver) {\r\n      getBinaryPromise().then(function(binary) {\r\n        return WebAssembly.instantiate(binary, info);\r\n      }).then(receiver).catch(function(reason) {\r\n        Module['printErr']('failed to asynchronously prepare wasm: ' + reason);\r\n        abort(reason);\r\n      });\r\n    }\r\n    // Prefer streaming instantiation if available.\r\n    if (!Module['wasmBinary'] &&\r\n        typeof WebAssembly.instantiateStreaming === 'function' &&\r\n        !isDataURI(wasmBinaryFile) &&\r\n        typeof fetch === 'function') {\r\n      WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: 'same-origin' }), info)\r\n        .then(receiveInstantiatedSource)\r\n        .catch(function(reason) {\r\n          // We expect the most common failure cause to be a bad MIME type for the binary,\r\n          // in which case falling back to ArrayBuffer instantiation should work.\r\n          Module['printErr']('wasm streaming compile failed: ' + reason);\r\n          Module['printErr']('falling back to ArrayBuffer instantiation');\r\n          instantiateArrayBuffer(receiveInstantiatedSource);\r\n        });\r\n    } else {\r\n      instantiateArrayBuffer(receiveInstantiatedSource);\r\n    }\r\n    return {}; // no exports yet; we'll fill them in later\r\n  }\r\n\r\n\r\n  // We may have a preloaded value in Module.asm, save it\r\n  Module['asmPreload'] = Module['asm'];\r\n\r\n  // Memory growth integration code\r\n\r\n  var asmjsReallocBuffer = Module['reallocBuffer'];\r\n\r\n  var wasmReallocBuffer = function(size) {\r\n    var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\r\n    size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\r\n    var old = Module['buffer'];\r\n    var oldSize = old.byteLength;\r\n    if (Module[\"usingWasm\"]) {\r\n      // native wasm support\r\n      try {\r\n        var result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\r\n        if (result !== (-1 | 0)) {\r\n          // success in native wasm memory growth, get the buffer from the memory\r\n          return Module['buffer'] = Module['wasmMemory'].buffer;\r\n        } else {\r\n          return null;\r\n        }\r\n      } catch(e) {\r\n        console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize  + ' bytes to ' + size + ' bytes, but got error: ' + e);\r\n        return null;\r\n      }\r\n    }\r\n  };\r\n\r\n  Module['reallocBuffer'] = function(size) {\r\n    if (finalMethod === 'asmjs') {\r\n      return asmjsReallocBuffer(size);\r\n    } else {\r\n      return wasmReallocBuffer(size);\r\n    }\r\n  };\r\n\r\n  // we may try more than one; this is the final one, that worked and we are using\r\n  var finalMethod = '';\r\n\r\n  // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\r\n  // the wasm module at that time, and it receives imports and provides exports and so forth, the app\r\n  // doesn't need to care that it is wasm or olyfilled wasm or asm.js.\r\n\r\n  Module['asm'] = function(global, env, providedBuffer) {\r\n    env = fixImports(env);\r\n\r\n    // import table\r\n    if (!env['table']) {\r\n      var TABLE_SIZE = Module['wasmTableSize'];\r\n      if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\r\n      var MAX_TABLE_SIZE = Module['wasmMaxTableSize'];\r\n      if (typeof WebAssembly === 'object' && typeof WebAssembly.Table === 'function') {\r\n        if (MAX_TABLE_SIZE !== undefined) {\r\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, 'maximum': MAX_TABLE_SIZE, 'element': 'anyfunc' });\r\n        } else {\r\n          env['table'] = new WebAssembly.Table({ 'initial': TABLE_SIZE, element: 'anyfunc' });\r\n        }\r\n      } else {\r\n        env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\r\n      }\r\n      Module['wasmTable'] = env['table'];\r\n    }\r\n\r\n    if (!env['memoryBase']) {\r\n      env['memoryBase'] = Module['STATIC_BASE']; // tell the memory segments where to place themselves\r\n    }\r\n    if (!env['tableBase']) {\r\n      env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change\r\n    }\r\n\r\n    // try the methods. each should return the exports if it succeeded\r\n\r\n    var exports;\r\n    exports = doNativeWasm(global, env, providedBuffer);\r\n\r\n    if (!exports) abort('no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods');\r\n\r\n\r\n    return exports;\r\n  };\r\n\r\n  var methodHandler = Module['asm']; // note our method handler, as we may modify Module['asm'] later\r\n}\r\n\r\nintegrateWasmJS();\r\n\r\n// === Body ===\r\n\r\nvar ASM_CONSTS = [function($0, $1) { $1 = Module.STDWEB_PRIVATE.to_js($1);Module.STDWEB_PRIVATE.from_js($0, (function(){alert (($1))})()); },\r\n function($0) { Module.STDWEB_PRIVATE.decrement_refcount( $0 ); },\r\n function() { console.error( 'Encountered a panic!' ); },\r\n function($0, $1) { console.error( 'Panic error message:', Module.STDWEB_PRIVATE.to_js_string( $0, $1 ) ); },\r\n function($0, $1, $2) { console.error( 'Panic location:', Module.STDWEB_PRIVATE.to_js_string( $0, $1 ) + ':' + $2 ); },\r\n function($0) { $0 = Module.STDWEB_PRIVATE.to_js($0);Module.STDWEB_PRIVATE.unregister_raw_value (($0)); }];\r\n\r\nfunction _emscripten_asm_const_ii(code, a0) {\r\n  return ASM_CONSTS[code](a0);\r\n}\r\n\r\nfunction _emscripten_asm_const_iii(code, a0, a1) {\r\n  return ASM_CONSTS[code](a0, a1);\r\n}\r\n\r\nfunction _emscripten_asm_const_i(code) {\r\n  return ASM_CONSTS[code]();\r\n}\r\n\r\nfunction _emscripten_asm_const_iiii(code, a0, a1, a2) {\r\n  return ASM_CONSTS[code](a0, a1, a2);\r\n}\r\n\r\n\r\n\r\n\r\nSTATIC_BASE = GLOBAL_BASE;\r\n\r\nSTATICTOP = STATIC_BASE + 55440;\r\n/* global initializers */  __ATINIT__.push();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar STATIC_BUMP = 55440;\r\nModule[\"STATIC_BASE\"] = STATIC_BASE;\r\nModule[\"STATIC_BUMP\"] = STATIC_BUMP;\r\n\r\n/* no memory initializer */\r\nvar tempDoublePtr = STATICTOP; STATICTOP += 16;\r\n\r\nassert(tempDoublePtr % 8 == 0);\r\n\r\nfunction copyTempFloat(ptr) { // functions, because inlining this code increases code size too much\r\n\r\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\r\n\r\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\r\n\r\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\r\n\r\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\r\n\r\n}\r\n\r\nfunction copyTempDouble(ptr) {\r\n\r\n  HEAP8[tempDoublePtr] = HEAP8[ptr];\r\n\r\n  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];\r\n\r\n  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];\r\n\r\n  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];\r\n\r\n  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];\r\n\r\n  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];\r\n\r\n  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];\r\n\r\n  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];\r\n\r\n}\r\n\r\n// {{PRE_LIBRARY}}\r\n\r\n\r\n  \r\n  \r\n  function __emscripten_traverse_stack(args) {\r\n      if (!args || !args.callee || !args.callee.name) {\r\n        return [null, '', ''];\r\n      }\r\n  \r\n      var funstr = args.callee.toString();\r\n      var funcname = args.callee.name;\r\n      var str = '(';\r\n      var first = true;\r\n      for (var i in args) {\r\n        var a = args[i];\r\n        if (!first) {\r\n          str += \", \";\r\n        }\r\n        first = false;\r\n        if (typeof a === 'number' || typeof a === 'string') {\r\n          str += a;\r\n        } else {\r\n          str += '(' + typeof a + ')';\r\n        }\r\n      }\r\n      str += ')';\r\n      var caller = args.callee.caller;\r\n      args = caller ? caller.arguments : [];\r\n      if (first)\r\n        str = '';\r\n      return [args, funcname, str];\r\n    }function _emscripten_get_callstack_js(flags) {\r\n      var callstack = jsStackTrace();\r\n  \r\n      // Find the symbols in the callstack that corresponds to the functions that report callstack information, and remove everyhing up to these from the output.\r\n      var iThisFunc = callstack.lastIndexOf('_emscripten_log');\r\n      var iThisFunc2 = callstack.lastIndexOf('_emscripten_get_callstack');\r\n      var iNextLine = callstack.indexOf('\\n', Math.max(iThisFunc, iThisFunc2))+1;\r\n      callstack = callstack.slice(iNextLine);\r\n  \r\n      // If user requested to see the original source stack, but no source map information is available, just fall back to showing the JS stack.\r\n      if (flags & 8/*EM_LOG_C_STACK*/ && typeof emscripten_source_map === 'undefined') {\r\n        warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with \"--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js\" linker flag to add source map loading to code.');\r\n        flags ^= 8/*EM_LOG_C_STACK*/;\r\n        flags |= 16/*EM_LOG_JS_STACK*/;\r\n      }\r\n  \r\n      var stack_args = null;\r\n      if (flags & 128 /*EM_LOG_FUNC_PARAMS*/) {\r\n        // To get the actual parameters to the functions, traverse the stack via the unfortunately deprecated 'arguments.callee' method, if it works:\r\n        stack_args = __emscripten_traverse_stack(arguments);\r\n        while (stack_args[1].indexOf('_emscripten_') >= 0)\r\n          stack_args = __emscripten_traverse_stack(stack_args[0]);\r\n      }\r\n      \r\n      // Process all lines:\r\n      var lines = callstack.split('\\n');\r\n      callstack = '';\r\n      var newFirefoxRe = new RegExp('\\\\s*(.*?)@(.*?):([0-9]+):([0-9]+)'); // New FF30 with column info: extract components of form '       Object._main@http://server.com:4324:12'\r\n      var firefoxRe = new RegExp('\\\\s*(.*?)@(.*):(.*)(:(.*))?'); // Old FF without column info: extract components of form '       Object._main@http://server.com:4324'\r\n      var chromeRe = new RegExp('\\\\s*at (.*?) \\\\\\((.*):(.*):(.*)\\\\\\)'); // Extract components of form '    at Object._main (http://server.com/file.html:4324:12)'\r\n      \r\n      for (var l in lines) {\r\n        var line = lines[l];\r\n  \r\n        var jsSymbolName = '';\r\n        var file = '';\r\n        var lineno = 0;\r\n        var column = 0;\r\n  \r\n        var parts = chromeRe.exec(line);\r\n        if (parts && parts.length == 5) {\r\n          jsSymbolName = parts[1];\r\n          file = parts[2];\r\n          lineno = parts[3];\r\n          column = parts[4];\r\n        } else {\r\n          parts = newFirefoxRe.exec(line);\r\n          if (!parts) parts = firefoxRe.exec(line);\r\n          if (parts && parts.length >= 4) {\r\n            jsSymbolName = parts[1];\r\n            file = parts[2];\r\n            lineno = parts[3];\r\n            column = parts[4]|0; // Old Firefox doesn't carry column information, but in new FF30, it is present. See https://bugzilla.mozilla.org/show_bug.cgi?id=762556\r\n          } else {\r\n            // Was not able to extract this line for demangling/sourcemapping purposes. Output it as-is.\r\n            callstack += line + '\\n';\r\n            continue;\r\n          }\r\n        }\r\n  \r\n        // Try to demangle the symbol, but fall back to showing the original JS symbol name if not available.\r\n        var cSymbolName = (flags & 32/*EM_LOG_DEMANGLE*/) ? demangle(jsSymbolName) : jsSymbolName;\r\n        if (!cSymbolName) {\r\n          cSymbolName = jsSymbolName;\r\n        }\r\n  \r\n        var haveSourceMap = false;\r\n  \r\n        if (flags & 8/*EM_LOG_C_STACK*/) {\r\n          var orig = emscripten_source_map.originalPositionFor({line: lineno, column: column});\r\n          haveSourceMap = (orig && orig.source);\r\n          if (haveSourceMap) {\r\n            if (flags & 64/*EM_LOG_NO_PATHS*/) {\r\n              orig.source = orig.source.substring(orig.source.replace(/\\\\/g, \"/\").lastIndexOf('/')+1);\r\n            }\r\n            callstack += '    at ' + cSymbolName + ' (' + orig.source + ':' + orig.line + ':' + orig.column + ')\\n';\r\n          }\r\n        }\r\n        if ((flags & 16/*EM_LOG_JS_STACK*/) || !haveSourceMap) {\r\n          if (flags & 64/*EM_LOG_NO_PATHS*/) {\r\n            file = file.substring(file.replace(/\\\\/g, \"/\").lastIndexOf('/')+1);\r\n          }\r\n          callstack += (haveSourceMap ? ('     = '+jsSymbolName) : ('    at '+cSymbolName)) + ' (' + file + ':' + lineno + ':' + column + ')\\n';\r\n        }\r\n        \r\n        // If we are still keeping track with the callstack by traversing via 'arguments.callee', print the function parameters as well.\r\n        if (flags & 128 /*EM_LOG_FUNC_PARAMS*/ && stack_args[0]) {\r\n          if (stack_args[1] == jsSymbolName && stack_args[2].length > 0) {\r\n            callstack = callstack.replace(/\\s+$/, '');\r\n            callstack += ' with values: ' + stack_args[1] + stack_args[2] + '\\n';\r\n          }\r\n          stack_args = __emscripten_traverse_stack(stack_args[0]);\r\n        }\r\n      }\r\n      // Trim extra whitespace at the end of the output.\r\n      callstack = callstack.replace(/\\s+$/, '');\r\n      return callstack;\r\n    }function __Unwind_Backtrace(func, arg) {\r\n      var trace = _emscripten_get_callstack_js();\r\n      var parts = trace.split('\\n');\r\n      for (var i = 0; i < parts.length; i++) {\r\n        var ret = Module['dynCall_iii'](func, 0, arg);\r\n        if (ret !== 0) return;\r\n      }\r\n    }\r\n\r\n  function __Unwind_FindEnclosingFunction() {\r\n      return 0; // we cannot succeed\r\n    }\r\n\r\n  function __Unwind_GetIPInfo() {\r\n      abort('Unwind_GetIPInfo');\r\n    }\r\n\r\n  function ___assert_fail(condition, filename, line, func) {\r\n      abort('Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function']);\r\n    }\r\n\r\n  \r\n  \r\n  function _emscripten_get_now() { abort() }\r\n  \r\n  function _emscripten_get_now_is_monotonic() {\r\n      // return whether emscripten_get_now is guaranteed monotonic; the Date.now\r\n      // implementation is not :(\r\n      return ENVIRONMENT_IS_NODE || (typeof dateNow !== 'undefined') ||\r\n          ((ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && self['performance'] && self['performance']['now']);\r\n    }\r\n  \r\n  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};\r\n  \r\n  function ___setErrNo(value) {\r\n      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;\r\n      else Module.printErr('failed to set errno from JS');\r\n      return value;\r\n    }function _clock_gettime(clk_id, tp) {\r\n      // int clock_gettime(clockid_t clk_id, struct timespec *tp);\r\n      var now;\r\n      if (clk_id === 0) {\r\n        now = Date.now();\r\n      } else if (clk_id === 1 && _emscripten_get_now_is_monotonic()) {\r\n        now = _emscripten_get_now();\r\n      } else {\r\n        ___setErrNo(ERRNO_CODES.EINVAL);\r\n        return -1;\r\n      }\r\n      HEAP32[((tp)>>2)]=(now/1000)|0; // seconds\r\n      HEAP32[(((tp)+(4))>>2)]=((now % 1000)*1000*1000)|0; // nanoseconds\r\n      return 0;\r\n    }function ___clock_gettime() {\r\n  return _clock_gettime.apply(null, arguments)\r\n  }\r\n\r\n  function ___cxa_allocate_exception(size) {\r\n      return _malloc(size);\r\n    }\r\n\r\n  function ___cxa_find_matching_catch_2() {\r\n          return ___cxa_find_matching_catch.apply(null, arguments);\r\n        }\r\n\r\n  \r\n  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()\r\n      return !!__ZSt18uncaught_exceptionv.uncaught_exception;\r\n    }\r\n  \r\n  \r\n  \r\n  var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:function (adjusted) {\r\n        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\r\n        for (var key in EXCEPTIONS.infos) {\r\n          var ptr = +key; // the iteration key is a string, and if we throw this, it must be an integer as that is what we look for\r\n          var info = EXCEPTIONS.infos[ptr];\r\n          if (info.adjusted === adjusted) {\r\n            return ptr;\r\n          }\r\n        }\r\n        return adjusted;\r\n      },addRef:function (ptr) {\r\n        if (!ptr) return;\r\n        var info = EXCEPTIONS.infos[ptr];\r\n        info.refcount++;\r\n      },decRef:function (ptr) {\r\n        if (!ptr) return;\r\n        var info = EXCEPTIONS.infos[ptr];\r\n        assert(info.refcount > 0);\r\n        info.refcount--;\r\n        // A rethrown exception can reach refcount 0; it must not be discarded\r\n        // Its next handler will clear the rethrown flag and addRef it, prior to\r\n        // final decRef and destruction here\r\n        if (info.refcount === 0 && !info.rethrown) {\r\n          if (info.destructor) {\r\n            Module['dynCall_vi'](info.destructor, ptr);\r\n          }\r\n          delete EXCEPTIONS.infos[ptr];\r\n          ___cxa_free_exception(ptr);\r\n        }\r\n      },clearRef:function (ptr) {\r\n        if (!ptr) return;\r\n        var info = EXCEPTIONS.infos[ptr];\r\n        info.refcount = 0;\r\n      }};\r\n  function ___resumeException(ptr) {\r\n      if (!EXCEPTIONS.last) { EXCEPTIONS.last = ptr; }\r\n      throw ptr;\r\n    }function ___cxa_find_matching_catch() {\r\n      var thrown = EXCEPTIONS.last;\r\n      if (!thrown) {\r\n        // just pass through the null ptr\r\n        return ((setTempRet0(0),0)|0);\r\n      }\r\n      var info = EXCEPTIONS.infos[thrown];\r\n      var throwntype = info.type;\r\n      if (!throwntype) {\r\n        // just pass through the thrown ptr\r\n        return ((setTempRet0(0),thrown)|0);\r\n      }\r\n      var typeArray = Array.prototype.slice.call(arguments);\r\n  \r\n      var pointer = Module['___cxa_is_pointer_type'](throwntype);\r\n      // can_catch receives a **, add indirection\r\n      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);\r\n      HEAP32[((___cxa_find_matching_catch.buffer)>>2)]=thrown;\r\n      thrown = ___cxa_find_matching_catch.buffer;\r\n      // The different catch blocks are denoted by different types.\r\n      // Due to inheritance, those types may not precisely match the\r\n      // type of the thrown object. Find one which matches, and\r\n      // return the type of the catch block which should be called.\r\n      for (var i = 0; i < typeArray.length; i++) {\r\n        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {\r\n          thrown = HEAP32[((thrown)>>2)]; // undo indirection\r\n          info.adjusted = thrown;\r\n          return ((setTempRet0(typeArray[i]),thrown)|0);\r\n        }\r\n      }\r\n      // Shouldn't happen unless we have bogus data in typeArray\r\n      // or encounter a type for which emscripten doesn't have suitable\r\n      // typeinfo defined. Best-efforts match just in case.\r\n      thrown = HEAP32[((thrown)>>2)]; // undo indirection\r\n      return ((setTempRet0(throwntype),thrown)|0);\r\n    }function ___cxa_throw(ptr, type, destructor) {\r\n      EXCEPTIONS.infos[ptr] = {\r\n        ptr: ptr,\r\n        adjusted: ptr,\r\n        type: type,\r\n        destructor: destructor,\r\n        refcount: 0,\r\n        caught: false,\r\n        rethrown: false\r\n      };\r\n      EXCEPTIONS.last = ptr;\r\n      if (!(\"uncaught_exception\" in __ZSt18uncaught_exceptionv)) {\r\n        __ZSt18uncaught_exceptionv.uncaught_exception = 1;\r\n      } else {\r\n        __ZSt18uncaught_exceptionv.uncaught_exception++;\r\n      }\r\n      throw ptr;\r\n    }\r\n\r\n  function ___gxx_personality_v0() {\r\n    }\r\n\r\n  function ___lock() {}\r\n\r\n  function ___map_file(pathname, size) {\r\n      ___setErrNo(ERRNO_CODES.EPERM);\r\n      return -1;\r\n    }\r\n\r\n\r\n  \r\n  \r\n  \r\n  var ERRNO_MESSAGES={0:\"Success\",1:\"Not super-user\",2:\"No such file or directory\",3:\"No such process\",4:\"Interrupted system call\",5:\"I/O error\",6:\"No such device or address\",7:\"Arg list too long\",8:\"Exec format error\",9:\"Bad file number\",10:\"No children\",11:\"No more processes\",12:\"Not enough core\",13:\"Permission denied\",14:\"Bad address\",15:\"Block device required\",16:\"Mount device busy\",17:\"File exists\",18:\"Cross-device link\",19:\"No such device\",20:\"Not a directory\",21:\"Is a directory\",22:\"Invalid argument\",23:\"Too many open files in system\",24:\"Too many open files\",25:\"Not a typewriter\",26:\"Text file busy\",27:\"File too large\",28:\"No space left on device\",29:\"Illegal seek\",30:\"Read only file system\",31:\"Too many links\",32:\"Broken pipe\",33:\"Math arg out of domain of func\",34:\"Math result not representable\",35:\"File locking deadlock error\",36:\"File or path name too long\",37:\"No record locks available\",38:\"Function not implemented\",39:\"Directory not empty\",40:\"Too many symbolic links\",42:\"No message of desired type\",43:\"Identifier removed\",44:\"Channel number out of range\",45:\"Level 2 not synchronized\",46:\"Level 3 halted\",47:\"Level 3 reset\",48:\"Link number out of range\",49:\"Protocol driver not attached\",50:\"No CSI structure available\",51:\"Level 2 halted\",52:\"Invalid exchange\",53:\"Invalid request descriptor\",54:\"Exchange full\",55:\"No anode\",56:\"Invalid request code\",57:\"Invalid slot\",59:\"Bad font file fmt\",60:\"Device not a stream\",61:\"No data (for no delay io)\",62:\"Timer expired\",63:\"Out of streams resources\",64:\"Machine is not on the network\",65:\"Package not installed\",66:\"The object is remote\",67:\"The link has been severed\",68:\"Advertise error\",69:\"Srmount error\",70:\"Communication error on send\",71:\"Protocol error\",72:\"Multihop attempted\",73:\"Cross mount point (not really error)\",74:\"Trying to read unreadable message\",75:\"Value too large for defined data type\",76:\"Given log. name not unique\",77:\"f.d. invalid for this operation\",78:\"Remote address changed\",79:\"Can   access a needed shared lib\",80:\"Accessing a corrupted shared lib\",81:\".lib section in a.out corrupted\",82:\"Attempting to link in too many libs\",83:\"Attempting to exec a shared library\",84:\"Illegal byte sequence\",86:\"Streams pipe error\",87:\"Too many users\",88:\"Socket operation on non-socket\",89:\"Destination address required\",90:\"Message too long\",91:\"Protocol wrong type for socket\",92:\"Protocol not available\",93:\"Unknown protocol\",94:\"Socket type not supported\",95:\"Not supported\",96:\"Protocol family not supported\",97:\"Address family not supported by protocol family\",98:\"Address already in use\",99:\"Address not available\",100:\"Network interface is not configured\",101:\"Network is unreachable\",102:\"Connection reset by network\",103:\"Connection aborted\",104:\"Connection reset by peer\",105:\"No buffer space available\",106:\"Socket is already connected\",107:\"Socket is not connected\",108:\"Can't send after socket shutdown\",109:\"Too many references\",110:\"Connection timed out\",111:\"Connection refused\",112:\"Host is down\",113:\"Host is unreachable\",114:\"Socket already connected\",115:\"Connection already in progress\",116:\"Stale file handle\",122:\"Quota exceeded\",123:\"No medium (in tape drive)\",125:\"Operation canceled\",130:\"Previous owner died\",131:\"State not recoverable\"};\r\n  \r\n  var PATH={splitPath:function (filename) {\r\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n        return splitPathRe.exec(filename).slice(1);\r\n      },normalizeArray:function (parts, allowAboveRoot) {\r\n        // if the path tries to go above the root, `up` ends up > 0\r\n        var up = 0;\r\n        for (var i = parts.length - 1; i >= 0; i--) {\r\n          var last = parts[i];\r\n          if (last === '.') {\r\n            parts.splice(i, 1);\r\n          } else if (last === '..') {\r\n            parts.splice(i, 1);\r\n            up++;\r\n          } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n          }\r\n        }\r\n        // if the path is allowed to go above the root, restore leading ..s\r\n        if (allowAboveRoot) {\r\n          for (; up; up--) {\r\n            parts.unshift('..');\r\n          }\r\n        }\r\n        return parts;\r\n      },normalize:function (path) {\r\n        var isAbsolute = path.charAt(0) === '/',\r\n            trailingSlash = path.substr(-1) === '/';\r\n        // Normalize the path\r\n        path = PATH.normalizeArray(path.split('/').filter(function(p) {\r\n          return !!p;\r\n        }), !isAbsolute).join('/');\r\n        if (!path && !isAbsolute) {\r\n          path = '.';\r\n        }\r\n        if (path && trailingSlash) {\r\n          path += '/';\r\n        }\r\n        return (isAbsolute ? '/' : '') + path;\r\n      },dirname:function (path) {\r\n        var result = PATH.splitPath(path),\r\n            root = result[0],\r\n            dir = result[1];\r\n        if (!root && !dir) {\r\n          // No dirname whatsoever\r\n          return '.';\r\n        }\r\n        if (dir) {\r\n          // It has a dirname, strip trailing slash\r\n          dir = dir.substr(0, dir.length - 1);\r\n        }\r\n        return root + dir;\r\n      },basename:function (path) {\r\n        // EMSCRIPTEN return '/'' for '/', not an empty string\r\n        if (path === '/') return '/';\r\n        var lastSlash = path.lastIndexOf('/');\r\n        if (lastSlash === -1) return path;\r\n        return path.substr(lastSlash+1);\r\n      },extname:function (path) {\r\n        return PATH.splitPath(path)[3];\r\n      },join:function () {\r\n        var paths = Array.prototype.slice.call(arguments, 0);\r\n        return PATH.normalize(paths.join('/'));\r\n      },join2:function (l, r) {\r\n        return PATH.normalize(l + '/' + r);\r\n      },resolve:function () {\r\n        var resolvedPath = '',\r\n          resolvedAbsolute = false;\r\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n          var path = (i >= 0) ? arguments[i] : FS.cwd();\r\n          // Skip empty and invalid entries\r\n          if (typeof path !== 'string') {\r\n            throw new TypeError('Arguments to path.resolve must be strings');\r\n          } else if (!path) {\r\n            return ''; // an invalid portion invalidates the whole thing\r\n          }\r\n          resolvedPath = path + '/' + resolvedPath;\r\n          resolvedAbsolute = path.charAt(0) === '/';\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {\r\n          return !!p;\r\n        }), !resolvedAbsolute).join('/');\r\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n      },relative:function (from, to) {\r\n        from = PATH.resolve(from).substr(1);\r\n        to = PATH.resolve(to).substr(1);\r\n        function trim(arr) {\r\n          var start = 0;\r\n          for (; start < arr.length; start++) {\r\n            if (arr[start] !== '') break;\r\n          }\r\n          var end = arr.length - 1;\r\n          for (; end >= 0; end--) {\r\n            if (arr[end] !== '') break;\r\n          }\r\n          if (start > end) return [];\r\n          return arr.slice(start, end - start + 1);\r\n        }\r\n        var fromParts = trim(from.split('/'));\r\n        var toParts = trim(to.split('/'));\r\n        var length = Math.min(fromParts.length, toParts.length);\r\n        var samePartsLength = length;\r\n        for (var i = 0; i < length; i++) {\r\n          if (fromParts[i] !== toParts[i]) {\r\n            samePartsLength = i;\r\n            break;\r\n          }\r\n        }\r\n        var outputParts = [];\r\n        for (var i = samePartsLength; i < fromParts.length; i++) {\r\n          outputParts.push('..');\r\n        }\r\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n        return outputParts.join('/');\r\n      }};\r\n  \r\n  var TTY={ttys:[],init:function () {\r\n        // https://github.com/kripken/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\r\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\r\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\r\n        //   // with text files until FS.init can be refactored.\r\n        //   process['stdin']['setEncoding']('utf8');\r\n        // }\r\n      },shutdown:function () {\r\n        // https://github.com/kripken/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\r\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\r\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\r\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\r\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\r\n        //   process['stdin']['pause']();\r\n        // }\r\n      },register:function (dev, ops) {\r\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\r\n        FS.registerDevice(dev, TTY.stream_ops);\r\n      },stream_ops:{open:function (stream) {\r\n          var tty = TTY.ttys[stream.node.rdev];\r\n          if (!tty) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n          }\r\n          stream.tty = tty;\r\n          stream.seekable = false;\r\n        },close:function (stream) {\r\n          // flush any pending line data\r\n          stream.tty.ops.flush(stream.tty);\r\n        },flush:function (stream) {\r\n          stream.tty.ops.flush(stream.tty);\r\n        },read:function (stream, buffer, offset, length, pos /* ignored */) {\r\n          if (!stream.tty || !stream.tty.ops.get_char) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\r\n          }\r\n          var bytesRead = 0;\r\n          for (var i = 0; i < length; i++) {\r\n            var result;\r\n            try {\r\n              result = stream.tty.ops.get_char(stream.tty);\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n            }\r\n            if (result === undefined && bytesRead === 0) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\r\n            }\r\n            if (result === null || result === undefined) break;\r\n            bytesRead++;\r\n            buffer[offset+i] = result;\r\n          }\r\n          if (bytesRead) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return bytesRead;\r\n        },write:function (stream, buffer, offset, length, pos) {\r\n          if (!stream.tty || !stream.tty.ops.put_char) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);\r\n          }\r\n          for (var i = 0; i < length; i++) {\r\n            try {\r\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n            }\r\n          }\r\n          if (length) {\r\n            stream.node.timestamp = Date.now();\r\n          }\r\n          return i;\r\n        }},default_tty_ops:{get_char:function (tty) {\r\n          if (!tty.input.length) {\r\n            var result = null;\r\n            if (ENVIRONMENT_IS_NODE) {\r\n              // we will read data by chunks of BUFSIZE\r\n              var BUFSIZE = 256;\r\n              var buf = new Buffer(BUFSIZE);\r\n              var bytesRead = 0;\r\n  \r\n              var isPosixPlatform = (process.platform != 'win32'); // Node doesn't offer a direct check, so test by exclusion\r\n  \r\n              var fd = process.stdin.fd;\r\n              if (isPosixPlatform) {\r\n                // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync)\r\n                var usingDevice = false;\r\n                try {\r\n                  fd = fs.openSync('/dev/stdin', 'r');\r\n                  usingDevice = true;\r\n                } catch (e) {}\r\n              }\r\n  \r\n              try {\r\n                bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);\r\n              } catch(e) {\r\n                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,\r\n                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.\r\n                if (e.toString().indexOf('EOF') != -1) bytesRead = 0;\r\n                else throw e;\r\n              }\r\n  \r\n              if (usingDevice) { fs.closeSync(fd); }\r\n              if (bytesRead > 0) {\r\n                result = buf.slice(0, bytesRead).toString('utf-8');\r\n              } else {\r\n                result = null;\r\n              }\r\n  \r\n            } else if (typeof window != 'undefined' &&\r\n              typeof window.prompt == 'function') {\r\n              // Browser.\r\n              result = window.prompt('Input: ');  // returns null on cancel\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            } else if (typeof readline == 'function') {\r\n              // Command line.\r\n              result = readline();\r\n              if (result !== null) {\r\n                result += '\\n';\r\n              }\r\n            }\r\n            if (!result) {\r\n              return null;\r\n            }\r\n            tty.input = intArrayFromString(result, true);\r\n          }\r\n          return tty.input.shift();\r\n        },put_char:function (tty, val) {\r\n          if (val === null || val === 10) {\r\n            Module['print'](UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\r\n          }\r\n        },flush:function (tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            Module['print'](UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }},default_tty1_ops:{put_char:function (tty, val) {\r\n          if (val === null || val === 10) {\r\n            Module['printErr'](UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val);\r\n          }\r\n        },flush:function (tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            Module['printErr'](UTF8ArrayToString(tty.output, 0));\r\n            tty.output = [];\r\n          }\r\n        }}};\r\n  \r\n  var MEMFS={ops_table:null,mount:function (mount) {\r\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\r\n      },createNode:function (parent, name, mode, dev) {\r\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n          // no supported\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        if (!MEMFS.ops_table) {\r\n          MEMFS.ops_table = {\r\n            dir: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                lookup: MEMFS.node_ops.lookup,\r\n                mknod: MEMFS.node_ops.mknod,\r\n                rename: MEMFS.node_ops.rename,\r\n                unlink: MEMFS.node_ops.unlink,\r\n                rmdir: MEMFS.node_ops.rmdir,\r\n                readdir: MEMFS.node_ops.readdir,\r\n                symlink: MEMFS.node_ops.symlink\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek\r\n              }\r\n            },\r\n            file: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: {\r\n                llseek: MEMFS.stream_ops.llseek,\r\n                read: MEMFS.stream_ops.read,\r\n                write: MEMFS.stream_ops.write,\r\n                allocate: MEMFS.stream_ops.allocate,\r\n                mmap: MEMFS.stream_ops.mmap,\r\n                msync: MEMFS.stream_ops.msync\r\n              }\r\n            },\r\n            link: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr,\r\n                readlink: MEMFS.node_ops.readlink\r\n              },\r\n              stream: {}\r\n            },\r\n            chrdev: {\r\n              node: {\r\n                getattr: MEMFS.node_ops.getattr,\r\n                setattr: MEMFS.node_ops.setattr\r\n              },\r\n              stream: FS.chrdev_stream_ops\r\n            }\r\n          };\r\n        }\r\n        var node = FS.createNode(parent, name, mode, dev);\r\n        if (FS.isDir(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.dir.node;\r\n          node.stream_ops = MEMFS.ops_table.dir.stream;\r\n          node.contents = {};\r\n        } else if (FS.isFile(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.file.node;\r\n          node.stream_ops = MEMFS.ops_table.file.stream;\r\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n          node.contents = null; \r\n        } else if (FS.isLink(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.link.node;\r\n          node.stream_ops = MEMFS.ops_table.link.stream;\r\n        } else if (FS.isChrdev(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.chrdev.node;\r\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n        }\r\n        node.timestamp = Date.now();\r\n        // add the new node to the parent\r\n        if (parent) {\r\n          parent.contents[name] = node;\r\n        }\r\n        return node;\r\n      },getFileDataAsRegularArray:function (node) {\r\n        if (node.contents && node.contents.subarray) {\r\n          var arr = [];\r\n          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);\r\n          return arr; // Returns a copy of the original data.\r\n        }\r\n        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.\r\n      },getFileDataAsTypedArray:function (node) {\r\n        if (!node.contents) return new Uint8Array;\r\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\r\n        return new Uint8Array(node.contents);\r\n      },expandFileStorage:function (node, newCapacity) {\r\n        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file\r\n        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to\r\n        // increase the size.\r\n        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {\r\n          node.contents = MEMFS.getFileDataAsRegularArray(node);\r\n          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.\r\n        }\r\n  \r\n        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.\r\n          var prevCapacity = node.contents ? node.contents.length : 0;\r\n          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\r\n          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n          // avoid overshooting the allocation cap by a very large margin.\r\n          var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);\r\n          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\r\n          var oldContents = node.contents;\r\n          node.contents = new Uint8Array(newCapacity); // Allocate new storage.\r\n          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\r\n          return;\r\n        }\r\n        // Not using a typed array to back the file storage. Use a standard JS array instead.\r\n        if (!node.contents && newCapacity > 0) node.contents = [];\r\n        while (node.contents.length < newCapacity) node.contents.push(0);\r\n      },resizeFileStorage:function (node, newSize) {\r\n        if (node.usedBytes == newSize) return;\r\n        if (newSize == 0) {\r\n          node.contents = null; // Fully decommit when requesting a resize to zero.\r\n          node.usedBytes = 0;\r\n          return;\r\n        }\r\n        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.\r\n          var oldContents = node.contents;\r\n          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.\r\n          if (oldContents) {\r\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\r\n          }\r\n          node.usedBytes = newSize;\r\n          return;\r\n        }\r\n        // Backing with a JS array.\r\n        if (!node.contents) node.contents = [];\r\n        if (node.contents.length > newSize) node.contents.length = newSize;\r\n        else while (node.contents.length < newSize) node.contents.push(0);\r\n        node.usedBytes = newSize;\r\n      },node_ops:{getattr:function (node) {\r\n          var attr = {};\r\n          // device numbers reuse inode numbers.\r\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n          attr.ino = node.id;\r\n          attr.mode = node.mode;\r\n          attr.nlink = 1;\r\n          attr.uid = 0;\r\n          attr.gid = 0;\r\n          attr.rdev = node.rdev;\r\n          if (FS.isDir(node.mode)) {\r\n            attr.size = 4096;\r\n          } else if (FS.isFile(node.mode)) {\r\n            attr.size = node.usedBytes;\r\n          } else if (FS.isLink(node.mode)) {\r\n            attr.size = node.link.length;\r\n          } else {\r\n            attr.size = 0;\r\n          }\r\n          attr.atime = new Date(node.timestamp);\r\n          attr.mtime = new Date(node.timestamp);\r\n          attr.ctime = new Date(node.timestamp);\r\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n          //       but this is not required by the standard.\r\n          attr.blksize = 4096;\r\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n          return attr;\r\n        },setattr:function (node, attr) {\r\n          if (attr.mode !== undefined) {\r\n            node.mode = attr.mode;\r\n          }\r\n          if (attr.timestamp !== undefined) {\r\n            node.timestamp = attr.timestamp;\r\n          }\r\n          if (attr.size !== undefined) {\r\n            MEMFS.resizeFileStorage(node, attr.size);\r\n          }\r\n        },lookup:function (parent, name) {\r\n          throw FS.genericErrors[ERRNO_CODES.ENOENT];\r\n        },mknod:function (parent, name, mode, dev) {\r\n          return MEMFS.createNode(parent, name, mode, dev);\r\n        },rename:function (old_node, new_dir, new_name) {\r\n          // if we're overwriting a directory at new_name, make sure it's empty.\r\n          if (FS.isDir(old_node.mode)) {\r\n            var new_node;\r\n            try {\r\n              new_node = FS.lookupNode(new_dir, new_name);\r\n            } catch (e) {\r\n            }\r\n            if (new_node) {\r\n              for (var i in new_node.contents) {\r\n                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\r\n              }\r\n            }\r\n          }\r\n          // do the internal rewiring\r\n          delete old_node.parent.contents[old_node.name];\r\n          old_node.name = new_name;\r\n          new_dir.contents[new_name] = old_node;\r\n          old_node.parent = new_dir;\r\n        },unlink:function (parent, name) {\r\n          delete parent.contents[name];\r\n        },rmdir:function (parent, name) {\r\n          var node = FS.lookupNode(parent, name);\r\n          for (var i in node.contents) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\r\n          }\r\n          delete parent.contents[name];\r\n        },readdir:function (node) {\r\n          var entries = ['.', '..']\r\n          for (var key in node.contents) {\r\n            if (!node.contents.hasOwnProperty(key)) {\r\n              continue;\r\n            }\r\n            entries.push(key);\r\n          }\r\n          return entries;\r\n        },symlink:function (parent, newname, oldpath) {\r\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\r\n          node.link = oldpath;\r\n          return node;\r\n        },readlink:function (node) {\r\n          if (!FS.isLink(node.mode)) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n          }\r\n          return node.link;\r\n        }},stream_ops:{read:function (stream, buffer, offset, length, position) {\r\n          var contents = stream.node.contents;\r\n          if (position >= stream.node.usedBytes) return 0;\r\n          var size = Math.min(stream.node.usedBytes - position, length);\r\n          assert(size >= 0);\r\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\r\n            buffer.set(contents.subarray(position, position + size), offset);\r\n          } else {\r\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n          }\r\n          return size;\r\n        },write:function (stream, buffer, offset, length, position, canOwn) {\r\n          if (!length) return 0;\r\n          var node = stream.node;\r\n          node.timestamp = Date.now();\r\n  \r\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\r\n            if (canOwn) {\r\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\r\n              node.contents = buffer.subarray(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\r\n              node.contents.set(buffer.subarray(offset, offset + length), position);\r\n              return length;\r\n            }\r\n          }\r\n  \r\n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n          MEMFS.expandFileStorage(node, position+length);\r\n          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.\r\n          else {\r\n            for (var i = 0; i < length; i++) {\r\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\r\n            }\r\n          }\r\n          node.usedBytes = Math.max(node.usedBytes, position+length);\r\n          return length;\r\n        },llseek:function (stream, offset, whence) {\r\n          var position = offset;\r\n          if (whence === 1) {  // SEEK_CUR.\r\n            position += stream.position;\r\n          } else if (whence === 2) {  // SEEK_END.\r\n            if (FS.isFile(stream.node.mode)) {\r\n              position += stream.node.usedBytes;\r\n            }\r\n          }\r\n          if (position < 0) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n          }\r\n          return position;\r\n        },allocate:function (stream, offset, length) {\r\n          MEMFS.expandFileStorage(stream.node, offset + length);\r\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n        },mmap:function (stream, buffer, offset, length, position, prot, flags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n          }\r\n          var ptr;\r\n          var allocated;\r\n          var contents = stream.node.contents;\r\n          // Only make a new copy when MAP_PRIVATE is specified.\r\n          if ( !(flags & 2) &&\r\n                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {\r\n            // We can't emulate MAP_SHARED when the file is not backed by the buffer\r\n            // we're mapping to (e.g. the HEAP buffer).\r\n            allocated = false;\r\n            ptr = contents.byteOffset;\r\n          } else {\r\n            // Try to avoid unnecessary slices.\r\n            if (position > 0 || position + length < stream.node.usedBytes) {\r\n              if (contents.subarray) {\r\n                contents = contents.subarray(position, position + length);\r\n              } else {\r\n                contents = Array.prototype.slice.call(contents, position, position + length);\r\n              }\r\n            }\r\n            allocated = true;\r\n            ptr = _malloc(length);\r\n            if (!ptr) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);\r\n            }\r\n            buffer.set(contents, ptr);\r\n          }\r\n          return { ptr: ptr, allocated: allocated };\r\n        },msync:function (stream, buffer, offset, length, mmapFlags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n          }\r\n          if (mmapFlags & 2) {\r\n            // MAP_PRIVATE calls need not to be synced back to underlying fs\r\n            return 0;\r\n          }\r\n  \r\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n          // should we check if bytesWritten and length are the same?\r\n          return 0;\r\n        }}};\r\n  \r\n  var IDBFS={dbs:{},indexedDB:function () {\r\n        if (typeof indexedDB !== 'undefined') return indexedDB;\r\n        var ret = null;\r\n        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n        assert(ret, 'IDBFS used, but indexedDB not supported');\r\n        return ret;\r\n      },DB_VERSION:21,DB_STORE_NAME:\"FILE_DATA\",mount:function (mount) {\r\n        // reuse all of the core MEMFS functionality\r\n        return MEMFS.mount.apply(null, arguments);\r\n      },syncfs:function (mount, populate, callback) {\r\n        IDBFS.getLocalSet(mount, function(err, local) {\r\n          if (err) return callback(err);\r\n  \r\n          IDBFS.getRemoteSet(mount, function(err, remote) {\r\n            if (err) return callback(err);\r\n  \r\n            var src = populate ? remote : local;\r\n            var dst = populate ? local : remote;\r\n  \r\n            IDBFS.reconcile(src, dst, callback);\r\n          });\r\n        });\r\n      },getDB:function (name, callback) {\r\n        // check the cache first\r\n        var db = IDBFS.dbs[name];\r\n        if (db) {\r\n          return callback(null, db);\r\n        }\r\n  \r\n        var req;\r\n        try {\r\n          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);\r\n        } catch (e) {\r\n          return callback(e);\r\n        }\r\n        if (!req) {\r\n          return callback(\"Unable to connect to IndexedDB\");\r\n        }\r\n        req.onupgradeneeded = function(e) {\r\n          var db = e.target.result;\r\n          var transaction = e.target.transaction;\r\n  \r\n          var fileStore;\r\n  \r\n          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {\r\n            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n          } else {\r\n            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);\r\n          }\r\n  \r\n          if (!fileStore.indexNames.contains('timestamp')) {\r\n            fileStore.createIndex('timestamp', 'timestamp', { unique: false });\r\n          }\r\n        };\r\n        req.onsuccess = function() {\r\n          db = req.result;\r\n  \r\n          // add to the cache\r\n          IDBFS.dbs[name] = db;\r\n          callback(null, db);\r\n        };\r\n        req.onerror = function(e) {\r\n          callback(this.error);\r\n          e.preventDefault();\r\n        };\r\n      },getLocalSet:function (mount, callback) {\r\n        var entries = {};\r\n  \r\n        function isRealDir(p) {\r\n          return p !== '.' && p !== '..';\r\n        };\r\n        function toAbsolute(root) {\r\n          return function(p) {\r\n            return PATH.join2(root, p);\r\n          }\r\n        };\r\n  \r\n        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));\r\n  \r\n        while (check.length) {\r\n          var path = check.pop();\r\n          var stat;\r\n  \r\n          try {\r\n            stat = FS.stat(path);\r\n          } catch (e) {\r\n            return callback(e);\r\n          }\r\n  \r\n          if (FS.isDir(stat.mode)) {\r\n            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));\r\n          }\r\n  \r\n          entries[path] = { timestamp: stat.mtime };\r\n        }\r\n  \r\n        return callback(null, { type: 'local', entries: entries });\r\n      },getRemoteSet:function (mount, callback) {\r\n        var entries = {};\r\n  \r\n        IDBFS.getDB(mount.mountpoint, function(err, db) {\r\n          if (err) return callback(err);\r\n  \r\n          try {\r\n            var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');\r\n            transaction.onerror = function(e) {\r\n              callback(this.error);\r\n              e.preventDefault();\r\n            };\r\n  \r\n            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n            var index = store.index('timestamp');\r\n  \r\n            index.openKeyCursor().onsuccess = function(event) {\r\n              var cursor = event.target.result;\r\n  \r\n              if (!cursor) {\r\n                return callback(null, { type: 'remote', db: db, entries: entries });\r\n              }\r\n  \r\n              entries[cursor.primaryKey] = { timestamp: cursor.key };\r\n  \r\n              cursor.continue();\r\n            };\r\n          } catch (e) {\r\n            return callback(e);\r\n          }\r\n        });\r\n      },loadLocalEntry:function (path, callback) {\r\n        var stat, node;\r\n  \r\n        try {\r\n          var lookup = FS.lookupPath(path);\r\n          node = lookup.node;\r\n          stat = FS.stat(path);\r\n        } catch (e) {\r\n          return callback(e);\r\n        }\r\n  \r\n        if (FS.isDir(stat.mode)) {\r\n          return callback(null, { timestamp: stat.mtime, mode: stat.mode });\r\n        } else if (FS.isFile(stat.mode)) {\r\n          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.\r\n          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.\r\n          node.contents = MEMFS.getFileDataAsTypedArray(node);\r\n          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });\r\n        } else {\r\n          return callback(new Error('node type not supported'));\r\n        }\r\n      },storeLocalEntry:function (path, entry, callback) {\r\n        try {\r\n          if (FS.isDir(entry.mode)) {\r\n            FS.mkdir(path, entry.mode);\r\n          } else if (FS.isFile(entry.mode)) {\r\n            FS.writeFile(path, entry.contents, { canOwn: true });\r\n          } else {\r\n            return callback(new Error('node type not supported'));\r\n          }\r\n  \r\n          FS.chmod(path, entry.mode);\r\n          FS.utime(path, entry.timestamp, entry.timestamp);\r\n        } catch (e) {\r\n          return callback(e);\r\n        }\r\n  \r\n        callback(null);\r\n      },removeLocalEntry:function (path, callback) {\r\n        try {\r\n          var lookup = FS.lookupPath(path);\r\n          var stat = FS.stat(path);\r\n  \r\n          if (FS.isDir(stat.mode)) {\r\n            FS.rmdir(path);\r\n          } else if (FS.isFile(stat.mode)) {\r\n            FS.unlink(path);\r\n          }\r\n        } catch (e) {\r\n          return callback(e);\r\n        }\r\n  \r\n        callback(null);\r\n      },loadRemoteEntry:function (store, path, callback) {\r\n        var req = store.get(path);\r\n        req.onsuccess = function(event) { callback(null, event.target.result); };\r\n        req.onerror = function(e) {\r\n          callback(this.error);\r\n          e.preventDefault();\r\n        };\r\n      },storeRemoteEntry:function (store, path, entry, callback) {\r\n        var req = store.put(entry, path);\r\n        req.onsuccess = function() { callback(null); };\r\n        req.onerror = function(e) {\r\n          callback(this.error);\r\n          e.preventDefault();\r\n        };\r\n      },removeRemoteEntry:function (store, path, callback) {\r\n        var req = store.delete(path);\r\n        req.onsuccess = function() { callback(null); };\r\n        req.onerror = function(e) {\r\n          callback(this.error);\r\n          e.preventDefault();\r\n        };\r\n      },reconcile:function (src, dst, callback) {\r\n        var total = 0;\r\n  \r\n        var create = [];\r\n        Object.keys(src.entries).forEach(function (key) {\r\n          var e = src.entries[key];\r\n          var e2 = dst.entries[key];\r\n          if (!e2 || e.timestamp > e2.timestamp) {\r\n            create.push(key);\r\n            total++;\r\n          }\r\n        });\r\n  \r\n        var remove = [];\r\n        Object.keys(dst.entries).forEach(function (key) {\r\n          var e = dst.entries[key];\r\n          var e2 = src.entries[key];\r\n          if (!e2) {\r\n            remove.push(key);\r\n            total++;\r\n          }\r\n        });\r\n  \r\n        if (!total) {\r\n          return callback(null);\r\n        }\r\n  \r\n        var errored = false;\r\n        var completed = 0;\r\n        var db = src.type === 'remote' ? src.db : dst.db;\r\n        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');\r\n        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);\r\n  \r\n        function done(err) {\r\n          if (err) {\r\n            if (!done.errored) {\r\n              done.errored = true;\r\n              return callback(err);\r\n            }\r\n            return;\r\n          }\r\n          if (++completed >= total) {\r\n            return callback(null);\r\n          }\r\n        };\r\n  \r\n        transaction.onerror = function(e) {\r\n          done(this.error);\r\n          e.preventDefault();\r\n        };\r\n  \r\n        // sort paths in ascending order so directory entries are created\r\n        // before the files inside them\r\n        create.sort().forEach(function (path) {\r\n          if (dst.type === 'local') {\r\n            IDBFS.loadRemoteEntry(store, path, function (err, entry) {\r\n              if (err) return done(err);\r\n              IDBFS.storeLocalEntry(path, entry, done);\r\n            });\r\n          } else {\r\n            IDBFS.loadLocalEntry(path, function (err, entry) {\r\n              if (err) return done(err);\r\n              IDBFS.storeRemoteEntry(store, path, entry, done);\r\n            });\r\n          }\r\n        });\r\n  \r\n        // sort paths in descending order so files are deleted before their\r\n        // parent directories\r\n        remove.sort().reverse().forEach(function(path) {\r\n          if (dst.type === 'local') {\r\n            IDBFS.removeLocalEntry(path, done);\r\n          } else {\r\n            IDBFS.removeRemoteEntry(store, path, done);\r\n          }\r\n        });\r\n      }};\r\n  \r\n  var NODEFS={isWindows:false,staticInit:function () {\r\n        NODEFS.isWindows = !!process.platform.match(/^win/);\r\n        var flags = process[\"binding\"](\"constants\");\r\n        // Node.js 4 compatibility: it has no namespaces for constants\r\n        if (flags[\"fs\"]) {\r\n          flags = flags[\"fs\"];\r\n        }\r\n        NODEFS.flagsForNodeMap = {\r\n          \"1024\": flags[\"O_APPEND\"],\r\n          \"64\": flags[\"O_CREAT\"],\r\n          \"128\": flags[\"O_EXCL\"],\r\n          \"0\": flags[\"O_RDONLY\"],\r\n          \"2\": flags[\"O_RDWR\"],\r\n          \"4096\": flags[\"O_SYNC\"],\r\n          \"512\": flags[\"O_TRUNC\"],\r\n          \"1\": flags[\"O_WRONLY\"]\r\n        };\r\n      },bufferFrom:function (arrayBuffer) {\r\n        // Node.js < 4.5 compatibility: Buffer.from does not support ArrayBuffer\r\n        // Buffer.from before 4.5 was just a method inherited from Uint8Array\r\n        // Buffer.alloc has been added with Buffer.from together, so check it instead\r\n        return Buffer.alloc ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);\r\n      },mount:function (mount) {\r\n        assert(ENVIRONMENT_IS_NODE);\r\n        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);\r\n      },createNode:function (parent, name, mode, dev) {\r\n        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        var node = FS.createNode(parent, name, mode);\r\n        node.node_ops = NODEFS.node_ops;\r\n        node.stream_ops = NODEFS.stream_ops;\r\n        return node;\r\n      },getMode:function (path) {\r\n        var stat;\r\n        try {\r\n          stat = fs.lstatSync(path);\r\n          if (NODEFS.isWindows) {\r\n            // Node.js on Windows never represents permission bit 'x', so\r\n            // propagate read bits to execute bits\r\n            stat.mode = stat.mode | ((stat.mode & 292) >> 2);\r\n          }\r\n        } catch (e) {\r\n          if (!e.code) throw e;\r\n          throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n        }\r\n        return stat.mode;\r\n      },realPath:function (node) {\r\n        var parts = [];\r\n        while (node.parent !== node) {\r\n          parts.push(node.name);\r\n          node = node.parent;\r\n        }\r\n        parts.push(node.mount.opts.root);\r\n        parts.reverse();\r\n        return PATH.join.apply(null, parts);\r\n      },flagsForNode:function (flags) {\r\n        flags &= ~0x200000 /*O_PATH*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\r\n        flags &= ~0x800 /*O_NONBLOCK*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\r\n        flags &= ~0x8000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.\r\n        flags &= ~0x80000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.\r\n        var newFlags = 0;\r\n        for (var k in NODEFS.flagsForNodeMap) {\r\n          if (flags & k) {\r\n            newFlags |= NODEFS.flagsForNodeMap[k];\r\n            flags ^= k;\r\n          }\r\n        }\r\n  \r\n        if (!flags) {\r\n          return newFlags;\r\n        } else {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n      },node_ops:{getattr:function (node) {\r\n          var path = NODEFS.realPath(node);\r\n          var stat;\r\n          try {\r\n            stat = fs.lstatSync(path);\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.\r\n          // See http://support.microsoft.com/kb/140365\r\n          if (NODEFS.isWindows && !stat.blksize) {\r\n            stat.blksize = 4096;\r\n          }\r\n          if (NODEFS.isWindows && !stat.blocks) {\r\n            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;\r\n          }\r\n          return {\r\n            dev: stat.dev,\r\n            ino: stat.ino,\r\n            mode: stat.mode,\r\n            nlink: stat.nlink,\r\n            uid: stat.uid,\r\n            gid: stat.gid,\r\n            rdev: stat.rdev,\r\n            size: stat.size,\r\n            atime: stat.atime,\r\n            mtime: stat.mtime,\r\n            ctime: stat.ctime,\r\n            blksize: stat.blksize,\r\n            blocks: stat.blocks\r\n          };\r\n        },setattr:function (node, attr) {\r\n          var path = NODEFS.realPath(node);\r\n          try {\r\n            if (attr.mode !== undefined) {\r\n              fs.chmodSync(path, attr.mode);\r\n              // update the common node structure mode as well\r\n              node.mode = attr.mode;\r\n            }\r\n            if (attr.timestamp !== undefined) {\r\n              var date = new Date(attr.timestamp);\r\n              fs.utimesSync(path, date, date);\r\n            }\r\n            if (attr.size !== undefined) {\r\n              fs.truncateSync(path, attr.size);\r\n            }\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },lookup:function (parent, name) {\r\n          var path = PATH.join2(NODEFS.realPath(parent), name);\r\n          var mode = NODEFS.getMode(path);\r\n          return NODEFS.createNode(parent, name, mode);\r\n        },mknod:function (parent, name, mode, dev) {\r\n          var node = NODEFS.createNode(parent, name, mode, dev);\r\n          // create the backing node for this in the fs root as well\r\n          var path = NODEFS.realPath(node);\r\n          try {\r\n            if (FS.isDir(node.mode)) {\r\n              fs.mkdirSync(path, node.mode);\r\n            } else {\r\n              fs.writeFileSync(path, '', { mode: node.mode });\r\n            }\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n          return node;\r\n        },rename:function (oldNode, newDir, newName) {\r\n          var oldPath = NODEFS.realPath(oldNode);\r\n          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);\r\n          try {\r\n            fs.renameSync(oldPath, newPath);\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },unlink:function (parent, name) {\r\n          var path = PATH.join2(NODEFS.realPath(parent), name);\r\n          try {\r\n            fs.unlinkSync(path);\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },rmdir:function (parent, name) {\r\n          var path = PATH.join2(NODEFS.realPath(parent), name);\r\n          try {\r\n            fs.rmdirSync(path);\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },readdir:function (node) {\r\n          var path = NODEFS.realPath(node);\r\n          try {\r\n            return fs.readdirSync(path);\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },symlink:function (parent, newName, oldPath) {\r\n          var newPath = PATH.join2(NODEFS.realPath(parent), newName);\r\n          try {\r\n            fs.symlinkSync(oldPath, newPath);\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },readlink:function (node) {\r\n          var path = NODEFS.realPath(node);\r\n          try {\r\n            path = fs.readlinkSync(path);\r\n            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);\r\n            return path;\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        }},stream_ops:{open:function (stream) {\r\n          var path = NODEFS.realPath(stream.node);\r\n          try {\r\n            if (FS.isFile(stream.node.mode)) {\r\n              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));\r\n            }\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },close:function (stream) {\r\n          try {\r\n            if (FS.isFile(stream.node.mode) && stream.nfd) {\r\n              fs.closeSync(stream.nfd);\r\n            }\r\n          } catch (e) {\r\n            if (!e.code) throw e;\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },read:function (stream, buffer, offset, length, position) {\r\n          // Node.js < 6 compatibility: node errors on 0 length reads\r\n          if (length === 0) return 0;\r\n          try {\r\n            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },write:function (stream, buffer, offset, length, position) {\r\n          try {\r\n            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n          }\r\n        },llseek:function (stream, offset, whence) {\r\n          var position = offset;\r\n          if (whence === 1) {  // SEEK_CUR.\r\n            position += stream.position;\r\n          } else if (whence === 2) {  // SEEK_END.\r\n            if (FS.isFile(stream.node.mode)) {\r\n              try {\r\n                var stat = fs.fstatSync(stream.nfd);\r\n                position += stat.size;\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(ERRNO_CODES[e.code]);\r\n              }\r\n            }\r\n          }\r\n  \r\n          if (position < 0) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n          }\r\n  \r\n          return position;\r\n        }}};\r\n  \r\n  var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:function (mount) {\r\n        assert(ENVIRONMENT_IS_WORKER);\r\n        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();\r\n        var root = WORKERFS.createNode(null, '/', WORKERFS.DIR_MODE, 0);\r\n        var createdParents = {};\r\n        function ensureParent(path) {\r\n          // return the parent node, creating subdirs as necessary\r\n          var parts = path.split('/');\r\n          var parent = root;\r\n          for (var i = 0; i < parts.length-1; i++) {\r\n            var curr = parts.slice(0, i+1).join('/');\r\n            // Issue 4254: Using curr as a node name will prevent the node\r\n            // from being found in FS.nameTable when FS.open is called on\r\n            // a path which holds a child of this node,\r\n            // given that all FS functions assume node names\r\n            // are just their corresponding parts within their given path,\r\n            // rather than incremental aggregates which include their parent's\r\n            // directories.\r\n            if (!createdParents[curr]) {\r\n              createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);\r\n            }\r\n            parent = createdParents[curr];\r\n          }\r\n          return parent;\r\n        }\r\n        function base(path) {\r\n          var parts = path.split('/');\r\n          return parts[parts.length-1];\r\n        }\r\n        // We also accept FileList here, by using Array.prototype\r\n        Array.prototype.forEach.call(mount.opts[\"files\"] || [], function(file) {\r\n          WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);\r\n        });\r\n        (mount.opts[\"blobs\"] || []).forEach(function(obj) {\r\n          WORKERFS.createNode(ensureParent(obj[\"name\"]), base(obj[\"name\"]), WORKERFS.FILE_MODE, 0, obj[\"data\"]);\r\n        });\r\n        (mount.opts[\"packages\"] || []).forEach(function(pack) {\r\n          pack['metadata'].files.forEach(function(file) {\r\n            var name = file.filename.substr(1); // remove initial slash\r\n            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack['blob'].slice(file.start, file.end));\r\n          });\r\n        });\r\n        return root;\r\n      },createNode:function (parent, name, mode, dev, contents, mtime) {\r\n        var node = FS.createNode(parent, name, mode);\r\n        node.mode = mode;\r\n        node.node_ops = WORKERFS.node_ops;\r\n        node.stream_ops = WORKERFS.stream_ops;\r\n        node.timestamp = (mtime || new Date).getTime();\r\n        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);\r\n        if (mode === WORKERFS.FILE_MODE) {\r\n          node.size = contents.size;\r\n          node.contents = contents;\r\n        } else {\r\n          node.size = 4096;\r\n          node.contents = {};\r\n        }\r\n        if (parent) {\r\n          parent.contents[name] = node;\r\n        }\r\n        return node;\r\n      },node_ops:{getattr:function (node) {\r\n          return {\r\n            dev: 1,\r\n            ino: undefined,\r\n            mode: node.mode,\r\n            nlink: 1,\r\n            uid: 0,\r\n            gid: 0,\r\n            rdev: undefined,\r\n            size: node.size,\r\n            atime: new Date(node.timestamp),\r\n            mtime: new Date(node.timestamp),\r\n            ctime: new Date(node.timestamp),\r\n            blksize: 4096,\r\n            blocks: Math.ceil(node.size / 4096),\r\n          };\r\n        },setattr:function (node, attr) {\r\n          if (attr.mode !== undefined) {\r\n            node.mode = attr.mode;\r\n          }\r\n          if (attr.timestamp !== undefined) {\r\n            node.timestamp = attr.timestamp;\r\n          }\r\n        },lookup:function (parent, name) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        },mknod:function (parent, name, mode, dev) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        },rename:function (oldNode, newDir, newName) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        },unlink:function (parent, name) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        },rmdir:function (parent, name) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        },readdir:function (node) {\r\n          var entries = ['.', '..'];\r\n          for (var key in node.contents) {\r\n            if (!node.contents.hasOwnProperty(key)) {\r\n              continue;\r\n            }\r\n            entries.push(key);\r\n          }\r\n          return entries;\r\n        },symlink:function (parent, newName, oldPath) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        },readlink:function (node) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }},stream_ops:{read:function (stream, buffer, offset, length, position) {\r\n          if (position >= stream.node.size) return 0;\r\n          var chunk = stream.node.contents.slice(position, position + length);\r\n          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);\r\n          buffer.set(new Uint8Array(ab), offset);\r\n          return chunk.size;\r\n        },write:function (stream, buffer, offset, length, position) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n        },llseek:function (stream, offset, whence) {\r\n          var position = offset;\r\n          if (whence === 1) {  // SEEK_CUR.\r\n            position += stream.position;\r\n          } else if (whence === 2) {  // SEEK_END.\r\n            if (FS.isFile(stream.node.mode)) {\r\n              position += stream.node.size;\r\n            }\r\n          }\r\n          if (position < 0) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n          }\r\n          return position;\r\n        }}};\r\n  \r\n  var _stdin=STATICTOP; STATICTOP += 16;;\r\n  \r\n  var _stdout=STATICTOP; STATICTOP += 16;;\r\n  \r\n  var _stderr=STATICTOP; STATICTOP += 16;;var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function (e) {\r\n        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();\r\n        return ___setErrNo(e.errno);\r\n      },lookupPath:function (path, opts) {\r\n        path = PATH.resolve(FS.cwd(), path);\r\n        opts = opts || {};\r\n  \r\n        if (!path) return { path: '', node: null };\r\n  \r\n        var defaults = {\r\n          follow_mount: true,\r\n          recurse_count: 0\r\n        };\r\n        for (var key in defaults) {\r\n          if (opts[key] === undefined) {\r\n            opts[key] = defaults[key];\r\n          }\r\n        }\r\n  \r\n        if (opts.recurse_count > 8) {  // max recursive lookup of 8\r\n          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\r\n        }\r\n  \r\n        // split the path\r\n        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {\r\n          return !!p;\r\n        }), false);\r\n  \r\n        // start at the root\r\n        var current = FS.root;\r\n        var current_path = '/';\r\n  \r\n        for (var i = 0; i < parts.length; i++) {\r\n          var islast = (i === parts.length-1);\r\n          if (islast && opts.parent) {\r\n            // stop resolving\r\n            break;\r\n          }\r\n  \r\n          current = FS.lookupNode(current, parts[i]);\r\n          current_path = PATH.join2(current_path, parts[i]);\r\n  \r\n          // jump to the mount's root node if this is a mountpoint\r\n          if (FS.isMountpoint(current)) {\r\n            if (!islast || (islast && opts.follow_mount)) {\r\n              current = current.mounted.root;\r\n            }\r\n          }\r\n  \r\n          // by default, lookupPath will not follow a symlink if it is the final path component.\r\n          // setting opts.follow = true will override this behavior.\r\n          if (!islast || opts.follow) {\r\n            var count = 0;\r\n            while (FS.isLink(current.mode)) {\r\n              var link = FS.readlink(current_path);\r\n              current_path = PATH.resolve(PATH.dirname(current_path), link);\r\n  \r\n              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });\r\n              current = lookup.node;\r\n  \r\n              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        return { path: current_path, node: current };\r\n      },getPath:function (node) {\r\n        var path;\r\n        while (true) {\r\n          if (FS.isRoot(node)) {\r\n            var mount = node.mount.mountpoint;\r\n            if (!path) return mount;\r\n            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;\r\n          }\r\n          path = path ? node.name + '/' + path : node.name;\r\n          node = node.parent;\r\n        }\r\n      },hashName:function (parentid, name) {\r\n        var hash = 0;\r\n  \r\n  \r\n        for (var i = 0; i < name.length; i++) {\r\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n        }\r\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n      },hashAddNode:function (node) {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        node.name_next = FS.nameTable[hash];\r\n        FS.nameTable[hash] = node;\r\n      },hashRemoveNode:function (node) {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        if (FS.nameTable[hash] === node) {\r\n          FS.nameTable[hash] = node.name_next;\r\n        } else {\r\n          var current = FS.nameTable[hash];\r\n          while (current) {\r\n            if (current.name_next === node) {\r\n              current.name_next = node.name_next;\r\n              break;\r\n            }\r\n            current = current.name_next;\r\n          }\r\n        }\r\n      },lookupNode:function (parent, name) {\r\n        var err = FS.mayLookup(parent);\r\n        if (err) {\r\n          throw new FS.ErrnoError(err, parent);\r\n        }\r\n        var hash = FS.hashName(parent.id, name);\r\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n          var nodeName = node.name;\r\n          if (node.parent.id === parent.id && nodeName === name) {\r\n            return node;\r\n          }\r\n        }\r\n        // if we failed to find it in the cache, call into the VFS\r\n        return FS.lookup(parent, name);\r\n      },createNode:function (parent, name, mode, rdev) {\r\n        if (!FS.FSNode) {\r\n          FS.FSNode = function(parent, name, mode, rdev) {\r\n            if (!parent) {\r\n              parent = this;  // root node sets parent to itself\r\n            }\r\n            this.parent = parent;\r\n            this.mount = parent.mount;\r\n            this.mounted = null;\r\n            this.id = FS.nextInode++;\r\n            this.name = name;\r\n            this.mode = mode;\r\n            this.node_ops = {};\r\n            this.stream_ops = {};\r\n            this.rdev = rdev;\r\n          };\r\n  \r\n          FS.FSNode.prototype = {};\r\n  \r\n          // compatibility\r\n          var readMode = 292 | 73;\r\n          var writeMode = 146;\r\n  \r\n          // NOTE we must use Object.defineProperties instead of individual calls to\r\n          // Object.defineProperty in order to make closure compiler happy\r\n          Object.defineProperties(FS.FSNode.prototype, {\r\n            read: {\r\n              get: function() { return (this.mode & readMode) === readMode; },\r\n              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }\r\n            },\r\n            write: {\r\n              get: function() { return (this.mode & writeMode) === writeMode; },\r\n              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }\r\n            },\r\n            isFolder: {\r\n              get: function() { return FS.isDir(this.mode); }\r\n            },\r\n            isDevice: {\r\n              get: function() { return FS.isChrdev(this.mode); }\r\n            }\r\n          });\r\n        }\r\n  \r\n        var node = new FS.FSNode(parent, name, mode, rdev);\r\n  \r\n        FS.hashAddNode(node);\r\n  \r\n        return node;\r\n      },destroyNode:function (node) {\r\n        FS.hashRemoveNode(node);\r\n      },isRoot:function (node) {\r\n        return node === node.parent;\r\n      },isMountpoint:function (node) {\r\n        return !!node.mounted;\r\n      },isFile:function (mode) {\r\n        return (mode & 61440) === 32768;\r\n      },isDir:function (mode) {\r\n        return (mode & 61440) === 16384;\r\n      },isLink:function (mode) {\r\n        return (mode & 61440) === 40960;\r\n      },isChrdev:function (mode) {\r\n        return (mode & 61440) === 8192;\r\n      },isBlkdev:function (mode) {\r\n        return (mode & 61440) === 24576;\r\n      },isFIFO:function (mode) {\r\n        return (mode & 61440) === 4096;\r\n      },isSocket:function (mode) {\r\n        return (mode & 49152) === 49152;\r\n      },flagModes:{\"r\":0,\"rs\":1052672,\"r+\":2,\"w\":577,\"wx\":705,\"xw\":705,\"w+\":578,\"wx+\":706,\"xw+\":706,\"a\":1089,\"ax\":1217,\"xa\":1217,\"a+\":1090,\"ax+\":1218,\"xa+\":1218},modeStringToFlags:function (str) {\r\n        var flags = FS.flagModes[str];\r\n        if (typeof flags === 'undefined') {\r\n          throw new Error('Unknown file open mode: ' + str);\r\n        }\r\n        return flags;\r\n      },flagsToPermissionString:function (flag) {\r\n        var perms = ['r', 'w', 'rw'][flag & 3];\r\n        if ((flag & 512)) {\r\n          perms += 'w';\r\n        }\r\n        return perms;\r\n      },nodePermissions:function (node, perms) {\r\n        if (FS.ignorePermissions) {\r\n          return 0;\r\n        }\r\n        // return 0 if any user, group or owner bits are set.\r\n        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {\r\n          return ERRNO_CODES.EACCES;\r\n        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {\r\n          return ERRNO_CODES.EACCES;\r\n        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {\r\n          return ERRNO_CODES.EACCES;\r\n        }\r\n        return 0;\r\n      },mayLookup:function (dir) {\r\n        var err = FS.nodePermissions(dir, 'x');\r\n        if (err) return err;\r\n        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;\r\n        return 0;\r\n      },mayCreate:function (dir, name) {\r\n        try {\r\n          var node = FS.lookupNode(dir, name);\r\n          return ERRNO_CODES.EEXIST;\r\n        } catch (e) {\r\n        }\r\n        return FS.nodePermissions(dir, 'wx');\r\n      },mayDelete:function (dir, name, isdir) {\r\n        var node;\r\n        try {\r\n          node = FS.lookupNode(dir, name);\r\n        } catch (e) {\r\n          return e.errno;\r\n        }\r\n        var err = FS.nodePermissions(dir, 'wx');\r\n        if (err) {\r\n          return err;\r\n        }\r\n        if (isdir) {\r\n          if (!FS.isDir(node.mode)) {\r\n            return ERRNO_CODES.ENOTDIR;\r\n          }\r\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n            return ERRNO_CODES.EBUSY;\r\n          }\r\n        } else {\r\n          if (FS.isDir(node.mode)) {\r\n            return ERRNO_CODES.EISDIR;\r\n          }\r\n        }\r\n        return 0;\r\n      },mayOpen:function (node, flags) {\r\n        if (!node) {\r\n          return ERRNO_CODES.ENOENT;\r\n        }\r\n        if (FS.isLink(node.mode)) {\r\n          return ERRNO_CODES.ELOOP;\r\n        } else if (FS.isDir(node.mode)) {\r\n          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write\r\n              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)\r\n            return ERRNO_CODES.EISDIR;\r\n          }\r\n        }\r\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {\r\n        fd_start = fd_start || 0;\r\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\r\n        for (var fd = fd_start; fd <= fd_end; fd++) {\r\n          if (!FS.streams[fd]) {\r\n            return fd;\r\n          }\r\n        }\r\n        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);\r\n      },getStream:function (fd) {\r\n        return FS.streams[fd];\r\n      },createStream:function (stream, fd_start, fd_end) {\r\n        if (!FS.FSStream) {\r\n          FS.FSStream = function(){};\r\n          FS.FSStream.prototype = {};\r\n          // compatibility\r\n          Object.defineProperties(FS.FSStream.prototype, {\r\n            object: {\r\n              get: function() { return this.node; },\r\n              set: function(val) { this.node = val; }\r\n            },\r\n            isRead: {\r\n              get: function() { return (this.flags & 2097155) !== 1; }\r\n            },\r\n            isWrite: {\r\n              get: function() { return (this.flags & 2097155) !== 0; }\r\n            },\r\n            isAppend: {\r\n              get: function() { return (this.flags & 1024); }\r\n            }\r\n          });\r\n        }\r\n        // clone it, so we can return an instance of FSStream\r\n        var newStream = new FS.FSStream();\r\n        for (var p in stream) {\r\n          newStream[p] = stream[p];\r\n        }\r\n        stream = newStream;\r\n        var fd = FS.nextfd(fd_start, fd_end);\r\n        stream.fd = fd;\r\n        FS.streams[fd] = stream;\r\n        return stream;\r\n      },closeStream:function (fd) {\r\n        FS.streams[fd] = null;\r\n      },chrdev_stream_ops:{open:function (stream) {\r\n          var device = FS.getDevice(stream.node.rdev);\r\n          // override node's stream ops with the device's\r\n          stream.stream_ops = device.stream_ops;\r\n          // forward the open call\r\n          if (stream.stream_ops.open) {\r\n            stream.stream_ops.open(stream);\r\n          }\r\n        },llseek:function () {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\r\n        }},major:function (dev) {\r\n        return ((dev) >> 8);\r\n      },minor:function (dev) {\r\n        return ((dev) & 0xff);\r\n      },makedev:function (ma, mi) {\r\n        return ((ma) << 8 | (mi));\r\n      },registerDevice:function (dev, ops) {\r\n        FS.devices[dev] = { stream_ops: ops };\r\n      },getDevice:function (dev) {\r\n        return FS.devices[dev];\r\n      },getMounts:function (mount) {\r\n        var mounts = [];\r\n        var check = [mount];\r\n  \r\n        while (check.length) {\r\n          var m = check.pop();\r\n  \r\n          mounts.push(m);\r\n  \r\n          check.push.apply(check, m.mounts);\r\n        }\r\n  \r\n        return mounts;\r\n      },syncfs:function (populate, callback) {\r\n        if (typeof(populate) === 'function') {\r\n          callback = populate;\r\n          populate = false;\r\n        }\r\n  \r\n        FS.syncFSRequests++;\r\n  \r\n        if (FS.syncFSRequests > 1) {\r\n          console.log('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');\r\n        }\r\n  \r\n        var mounts = FS.getMounts(FS.root.mount);\r\n        var completed = 0;\r\n  \r\n        function doCallback(err) {\r\n          assert(FS.syncFSRequests > 0);\r\n          FS.syncFSRequests--;\r\n          return callback(err);\r\n        }\r\n  \r\n        function done(err) {\r\n          if (err) {\r\n            if (!done.errored) {\r\n              done.errored = true;\r\n              return doCallback(err);\r\n            }\r\n            return;\r\n          }\r\n          if (++completed >= mounts.length) {\r\n            doCallback(null);\r\n          }\r\n        };\r\n  \r\n        // sync all mounts\r\n        mounts.forEach(function (mount) {\r\n          if (!mount.type.syncfs) {\r\n            return done(null);\r\n          }\r\n          mount.type.syncfs(mount, populate, done);\r\n        });\r\n      },mount:function (type, opts, mountpoint) {\r\n        var root = mountpoint === '/';\r\n        var pseudo = !mountpoint;\r\n        var node;\r\n  \r\n        if (root && FS.root) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\r\n        } else if (!root && !pseudo) {\r\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n          mountpoint = lookup.path;  // use the absolute path\r\n          node = lookup.node;\r\n  \r\n          if (FS.isMountpoint(node)) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\r\n          }\r\n  \r\n          if (!FS.isDir(node.mode)) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\r\n          }\r\n        }\r\n  \r\n        var mount = {\r\n          type: type,\r\n          opts: opts,\r\n          mountpoint: mountpoint,\r\n          mounts: []\r\n        };\r\n  \r\n        // create a root node for the fs\r\n        var mountRoot = type.mount(mount);\r\n        mountRoot.mount = mount;\r\n        mount.root = mountRoot;\r\n  \r\n        if (root) {\r\n          FS.root = mountRoot;\r\n        } else if (node) {\r\n          // set as a mountpoint\r\n          node.mounted = mount;\r\n  \r\n          // add the new mount to the current mount's children\r\n          if (node.mount) {\r\n            node.mount.mounts.push(mount);\r\n          }\r\n        }\r\n  \r\n        return mountRoot;\r\n      },unmount:function (mountpoint) {\r\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n        if (!FS.isMountpoint(lookup.node)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n  \r\n        // destroy the nodes for this mount, and all its child mounts\r\n        var node = lookup.node;\r\n        var mount = node.mounted;\r\n        var mounts = FS.getMounts(mount);\r\n  \r\n        Object.keys(FS.nameTable).forEach(function (hash) {\r\n          var current = FS.nameTable[hash];\r\n  \r\n          while (current) {\r\n            var next = current.name_next;\r\n  \r\n            if (mounts.indexOf(current.mount) !== -1) {\r\n              FS.destroyNode(current);\r\n            }\r\n  \r\n            current = next;\r\n          }\r\n        });\r\n  \r\n        // no longer a mountpoint\r\n        node.mounted = null;\r\n  \r\n        // remove this mount from the child mounts\r\n        var idx = node.mount.mounts.indexOf(mount);\r\n        assert(idx !== -1);\r\n        node.mount.mounts.splice(idx, 1);\r\n      },lookup:function (parent, name) {\r\n        return parent.node_ops.lookup(parent, name);\r\n      },mknod:function (path, mode, dev) {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        if (!name || name === '.' || name === '..') {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        var err = FS.mayCreate(parent, name);\r\n        if (err) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        if (!parent.node_ops.mknod) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        return parent.node_ops.mknod(parent, name, mode, dev);\r\n      },create:function (path, mode) {\r\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\r\n        mode &= 4095;\r\n        mode |= 32768;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdir:function (path, mode) {\r\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\r\n        mode &= 511 | 512;\r\n        mode |= 16384;\r\n        return FS.mknod(path, mode, 0);\r\n      },mkdirTree:function (path, mode) {\r\n        var dirs = path.split('/');\r\n        var d = '';\r\n        for (var i = 0; i < dirs.length; ++i) {\r\n          if (!dirs[i]) continue;\r\n          d += '/' + dirs[i];\r\n          try {\r\n            FS.mkdir(d, mode);\r\n          } catch(e) {\r\n            if (e.errno != ERRNO_CODES.EEXIST) throw e;\r\n          }\r\n        }\r\n      },mkdev:function (path, mode, dev) {\r\n        if (typeof(dev) === 'undefined') {\r\n          dev = mode;\r\n          mode = 438 /* 0666 */;\r\n        }\r\n        mode |= 8192;\r\n        return FS.mknod(path, mode, dev);\r\n      },symlink:function (oldpath, newpath) {\r\n        if (!PATH.resolve(oldpath)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        }\r\n        var lookup = FS.lookupPath(newpath, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        }\r\n        var newname = PATH.basename(newpath);\r\n        var err = FS.mayCreate(parent, newname);\r\n        if (err) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        if (!parent.node_ops.symlink) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        return parent.node_ops.symlink(parent, newname, oldpath);\r\n      },rename:function (old_path, new_path) {\r\n        var old_dirname = PATH.dirname(old_path);\r\n        var new_dirname = PATH.dirname(new_path);\r\n        var old_name = PATH.basename(old_path);\r\n        var new_name = PATH.basename(new_path);\r\n        // parents must exist\r\n        var lookup, old_dir, new_dir;\r\n        try {\r\n          lookup = FS.lookupPath(old_path, { parent: true });\r\n          old_dir = lookup.node;\r\n          lookup = FS.lookupPath(new_path, { parent: true });\r\n          new_dir = lookup.node;\r\n        } catch (e) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\r\n        }\r\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        // need to be part of the same mount\r\n        if (old_dir.mount !== new_dir.mount) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);\r\n        }\r\n        // source must exist\r\n        var old_node = FS.lookupNode(old_dir, old_name);\r\n        // old path should not be an ancestor of the new path\r\n        var relative = PATH.relative(old_path, new_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        // new path should not be an ancestor of the old path\r\n        relative = PATH.relative(new_path, old_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);\r\n        }\r\n        // see if the new path already exists\r\n        var new_node;\r\n        try {\r\n          new_node = FS.lookupNode(new_dir, new_name);\r\n        } catch (e) {\r\n          // not fatal\r\n        }\r\n        // early out if nothing needs to change\r\n        if (old_node === new_node) {\r\n          return;\r\n        }\r\n        // we'll need to delete the old entry\r\n        var isdir = FS.isDir(old_node.mode);\r\n        var err = FS.mayDelete(old_dir, old_name, isdir);\r\n        if (err) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        // need delete permissions if we'll be overwriting.\r\n        // need create permissions if new doesn't already exist.\r\n        err = new_node ?\r\n          FS.mayDelete(new_dir, new_name, isdir) :\r\n          FS.mayCreate(new_dir, new_name);\r\n        if (err) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        if (!old_dir.node_ops.rename) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\r\n        }\r\n        // if we are going to change the parent, check write permissions\r\n        if (new_dir !== old_dir) {\r\n          err = FS.nodePermissions(old_dir, 'w');\r\n          if (err) {\r\n            throw new FS.ErrnoError(err);\r\n          }\r\n        }\r\n        try {\r\n          if (FS.trackingDelegate['willMovePath']) {\r\n            FS.trackingDelegate['willMovePath'](old_path, new_path);\r\n          }\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['willMovePath']('\"+old_path+\"', '\"+new_path+\"') threw an exception: \" + e.message);\r\n        }\r\n        // remove the node from the lookup hash\r\n        FS.hashRemoveNode(old_node);\r\n        // do the underlying fs rename\r\n        try {\r\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          // add the node back to the hash (in case node_ops.rename\r\n          // changed its name)\r\n          FS.hashAddNode(old_node);\r\n        }\r\n        try {\r\n          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['onMovePath']('\"+old_path+\"', '\"+new_path+\"') threw an exception: \" + e.message);\r\n        }\r\n      },rmdir:function (path) {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var err = FS.mayDelete(parent, name, true);\r\n        if (err) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        if (!parent.node_ops.rmdir) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\r\n        }\r\n        try {\r\n          if (FS.trackingDelegate['willDeletePath']) {\r\n            FS.trackingDelegate['willDeletePath'](path);\r\n          }\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['willDeletePath']('\"+path+\"') threw an exception: \" + e.message);\r\n        }\r\n        parent.node_ops.rmdir(parent, name);\r\n        FS.destroyNode(node);\r\n        try {\r\n          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['onDeletePath']('\"+path+\"') threw an exception: \" + e.message);\r\n        }\r\n      },readdir:function (path) {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        if (!node.node_ops.readdir) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\r\n        }\r\n        return node.node_ops.readdir(node);\r\n      },unlink:function (path) {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var err = FS.mayDelete(parent, name, false);\r\n        if (err) {\r\n          // According to POSIX, we should map EISDIR to EPERM, but\r\n          // we instead do what Linux does (and we must, as we use\r\n          // the musl linux libc).\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        if (!parent.node_ops.unlink) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);\r\n        }\r\n        try {\r\n          if (FS.trackingDelegate['willDeletePath']) {\r\n            FS.trackingDelegate['willDeletePath'](path);\r\n          }\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['willDeletePath']('\"+path+\"') threw an exception: \" + e.message);\r\n        }\r\n        parent.node_ops.unlink(parent, name);\r\n        FS.destroyNode(node);\r\n        try {\r\n          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['onDeletePath']('\"+path+\"') threw an exception: \" + e.message);\r\n        }\r\n      },readlink:function (path) {\r\n        var lookup = FS.lookupPath(path);\r\n        var link = lookup.node;\r\n        if (!link) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        }\r\n        if (!link.node_ops.readlink) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\r\n      },stat:function (path, dontFollow) {\r\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n        var node = lookup.node;\r\n        if (!node) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        }\r\n        if (!node.node_ops.getattr) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        return node.node_ops.getattr(node);\r\n      },lstat:function (path) {\r\n        return FS.stat(path, true);\r\n      },chmod:function (path, mode, dontFollow) {\r\n        var node;\r\n        if (typeof path === 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          mode: (mode & 4095) | (node.mode & ~4095),\r\n          timestamp: Date.now()\r\n        });\r\n      },lchmod:function (path, mode) {\r\n        FS.chmod(path, mode, true);\r\n      },fchmod:function (fd, mode) {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        FS.chmod(stream.node, mode);\r\n      },chown:function (path, uid, gid, dontFollow) {\r\n        var node;\r\n        if (typeof path === 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Date.now()\r\n          // we ignore the uid / gid for now\r\n        });\r\n      },lchown:function (path, uid, gid) {\r\n        FS.chown(path, uid, gid, true);\r\n      },fchown:function (fd, uid, gid) {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        FS.chown(stream.node, uid, gid);\r\n      },truncate:function (path, len) {\r\n        if (len < 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        var node;\r\n        if (typeof path === 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: true });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (!node.node_ops.setattr) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EPERM);\r\n        }\r\n        if (FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\r\n        }\r\n        if (!FS.isFile(node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        var err = FS.nodePermissions(node, 'w');\r\n        if (err) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        node.node_ops.setattr(node, {\r\n          size: len,\r\n          timestamp: Date.now()\r\n        });\r\n      },ftruncate:function (fd, len) {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        FS.truncate(stream.node, len);\r\n      },utime:function (path, atime, mtime) {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        node.node_ops.setattr(node, {\r\n          timestamp: Math.max(atime, mtime)\r\n        });\r\n      },open:function (path, flags, mode, fd_start, fd_end) {\r\n        if (path === \"\") {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        }\r\n        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;\r\n        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;\r\n        if ((flags & 64)) {\r\n          mode = (mode & 4095) | 32768;\r\n        } else {\r\n          mode = 0;\r\n        }\r\n        var node;\r\n        if (typeof path === 'object') {\r\n          node = path;\r\n        } else {\r\n          path = PATH.normalize(path);\r\n          try {\r\n            var lookup = FS.lookupPath(path, {\r\n              follow: !(flags & 131072)\r\n            });\r\n            node = lookup.node;\r\n          } catch (e) {\r\n            // ignore\r\n          }\r\n        }\r\n        // perhaps we need to create the node\r\n        var created = false;\r\n        if ((flags & 64)) {\r\n          if (node) {\r\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n            if ((flags & 128)) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);\r\n            }\r\n          } else {\r\n            // node doesn't exist, try to create it\r\n            node = FS.mknod(path, mode, 0);\r\n            created = true;\r\n          }\r\n        }\r\n        if (!node) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        }\r\n        // can't truncate a device\r\n        if (FS.isChrdev(node.mode)) {\r\n          flags &= ~512;\r\n        }\r\n        // if asked only for a directory, then this must be one\r\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\r\n        }\r\n        // check permissions, if this is not a file we just created now (it is ok to\r\n        // create and write to a file with read-only permissions; it is read-only\r\n        // for later use)\r\n        if (!created) {\r\n          var err = FS.mayOpen(node, flags);\r\n          if (err) {\r\n            throw new FS.ErrnoError(err);\r\n          }\r\n        }\r\n        // do truncation if necessary\r\n        if ((flags & 512)) {\r\n          FS.truncate(node, 0);\r\n        }\r\n        // we've already handled these, don't pass down to the underlying vfs\r\n        flags &= ~(128 | 512);\r\n  \r\n        // register the stream with the filesystem\r\n        var stream = FS.createStream({\r\n          node: node,\r\n          path: FS.getPath(node),  // we want the absolute path to the node\r\n          flags: flags,\r\n          seekable: true,\r\n          position: 0,\r\n          stream_ops: node.stream_ops,\r\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n          ungotten: [],\r\n          error: false\r\n        }, fd_start, fd_end);\r\n        // call the new stream's open function\r\n        if (stream.stream_ops.open) {\r\n          stream.stream_ops.open(stream);\r\n        }\r\n        if (Module['logReadFiles'] && !(flags & 1)) {\r\n          if (!FS.readFiles) FS.readFiles = {};\r\n          if (!(path in FS.readFiles)) {\r\n            FS.readFiles[path] = 1;\r\n            Module['printErr']('read file: ' + path);\r\n          }\r\n        }\r\n        try {\r\n          if (FS.trackingDelegate['onOpenFile']) {\r\n            var trackingFlags = 0;\r\n            if ((flags & 2097155) !== 1) {\r\n              trackingFlags |= FS.tracking.openFlags.READ;\r\n            }\r\n            if ((flags & 2097155) !== 0) {\r\n              trackingFlags |= FS.tracking.openFlags.WRITE;\r\n            }\r\n            FS.trackingDelegate['onOpenFile'](path, trackingFlags);\r\n          }\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['onOpenFile']('\"+path+\"', flags) threw an exception: \" + e.message);\r\n        }\r\n        return stream;\r\n      },close:function (stream) {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if (stream.getdents) stream.getdents = null; // free readdir state\r\n        try {\r\n          if (stream.stream_ops.close) {\r\n            stream.stream_ops.close(stream);\r\n          }\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          FS.closeStream(stream.fd);\r\n        }\r\n        stream.fd = null;\r\n      },isClosed:function (stream) {\r\n        return stream.fd === null;\r\n      },llseek:function (stream, offset, whence) {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if (!stream.seekable || !stream.stream_ops.llseek) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\r\n        }\r\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n        stream.ungotten = [];\r\n        return stream.position;\r\n      },read:function (stream, buffer, offset, length, position) {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\r\n        }\r\n        if (!stream.stream_ops.read) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        var seeking = typeof position !== 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\r\n        }\r\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n        if (!seeking) stream.position += bytesRead;\r\n        return bytesRead;\r\n      },write:function (stream, buffer, offset, length, position, canOwn) {\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);\r\n        }\r\n        if (!stream.stream_ops.write) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        if (stream.flags & 1024) {\r\n          // seek to the end before writing in append mode\r\n          FS.llseek(stream, 0, 2);\r\n        }\r\n        var seeking = typeof position !== 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);\r\n        }\r\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n        if (!seeking) stream.position += bytesWritten;\r\n        try {\r\n          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);\r\n        } catch(e) {\r\n          console.log(\"FS.trackingDelegate['onWriteToFile']('\"+path+\"') threw an exception: \" + e.message);\r\n        }\r\n        return bytesWritten;\r\n      },allocate:function (stream, offset, length) {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if (offset < 0 || length <= 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        }\r\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n        }\r\n        if (!stream.stream_ops.allocate) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);\r\n        }\r\n        stream.stream_ops.allocate(stream, offset, length);\r\n      },mmap:function (stream, buffer, offset, length, position, prot, flags) {\r\n        // TODO if PROT is PROT_WRITE, make sure we have write access\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.EACCES);\r\n        }\r\n        if (!stream.stream_ops.mmap) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);\r\n        }\r\n        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);\r\n      },msync:function (stream, buffer, offset, length, mmapFlags) {\r\n        if (!stream || !stream.stream_ops.msync) {\r\n          return 0;\r\n        }\r\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n      },munmap:function (stream) {\r\n        return 0;\r\n      },ioctl:function (stream, cmd, arg) {\r\n        if (!stream.stream_ops.ioctl) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);\r\n        }\r\n        return stream.stream_ops.ioctl(stream, cmd, arg);\r\n      },readFile:function (path, opts) {\r\n        opts = opts || {};\r\n        opts.flags = opts.flags || 'r';\r\n        opts.encoding = opts.encoding || 'binary';\r\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\r\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\r\n        }\r\n        var ret;\r\n        var stream = FS.open(path, opts.flags);\r\n        var stat = FS.stat(path);\r\n        var length = stat.size;\r\n        var buf = new Uint8Array(length);\r\n        FS.read(stream, buf, 0, length, 0);\r\n        if (opts.encoding === 'utf8') {\r\n          ret = UTF8ArrayToString(buf, 0);\r\n        } else if (opts.encoding === 'binary') {\r\n          ret = buf;\r\n        }\r\n        FS.close(stream);\r\n        return ret;\r\n      },writeFile:function (path, data, opts) {\r\n        opts = opts || {};\r\n        opts.flags = opts.flags || 'w';\r\n        var stream = FS.open(path, opts.flags, opts.mode);\r\n        if (typeof data === 'string') {\r\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\r\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n        } else if (ArrayBuffer.isView(data)) {\r\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n        } else {\r\n          throw new Error('Unsupported data type');\r\n        }\r\n        FS.close(stream);\r\n      },cwd:function () {\r\n        return FS.currentPath;\r\n      },chdir:function (path) {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        if (lookup.node === null) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);\r\n        }\r\n        if (!FS.isDir(lookup.node.mode)) {\r\n          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);\r\n        }\r\n        var err = FS.nodePermissions(lookup.node, 'x');\r\n        if (err) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        FS.currentPath = lookup.path;\r\n      },createDefaultDirectories:function () {\r\n        FS.mkdir('/tmp');\r\n        FS.mkdir('/home');\r\n        FS.mkdir('/home/web_user');\r\n      },createDefaultDevices:function () {\r\n        // create /dev\r\n        FS.mkdir('/dev');\r\n        // setup /dev/null\r\n        FS.registerDevice(FS.makedev(1, 3), {\r\n          read: function() { return 0; },\r\n          write: function(stream, buffer, offset, length, pos) { return length; }\r\n        });\r\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\r\n        // setup /dev/tty and /dev/tty1\r\n        // stderr needs to print output using Module['printErr']\r\n        // so we register a second tty just for it.\r\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\r\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\r\n        // setup /dev/[u]random\r\n        var random_device;\r\n        if (typeof crypto !== 'undefined') {\r\n          // for modern web browsers\r\n          var randomBuffer = new Uint8Array(1);\r\n          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };\r\n        } else if (ENVIRONMENT_IS_NODE) {\r\n          // for nodejs\r\n          random_device = function() { return require('crypto')['randomBytes'](1)[0]; };\r\n        } else {\r\n          // default for ES5 platforms\r\n          random_device = function() { return (Math.random()*256)|0; };\r\n        }\r\n        FS.createDevice('/dev', 'random', random_device);\r\n        FS.createDevice('/dev', 'urandom', random_device);\r\n        // we're not going to emulate the actual shm device,\r\n        // just create the tmp dirs that reside in it commonly\r\n        FS.mkdir('/dev/shm');\r\n        FS.mkdir('/dev/shm/tmp');\r\n      },createSpecialDirectories:function () {\r\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)\r\n        FS.mkdir('/proc');\r\n        FS.mkdir('/proc/self');\r\n        FS.mkdir('/proc/self/fd');\r\n        FS.mount({\r\n          mount: function() {\r\n            var node = FS.createNode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);\r\n            node.node_ops = {\r\n              lookup: function(parent, name) {\r\n                var fd = +name;\r\n                var stream = FS.getStream(fd);\r\n                if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n                var ret = {\r\n                  parent: null,\r\n                  mount: { mountpoint: 'fake' },\r\n                  node_ops: { readlink: function() { return stream.path } }\r\n                };\r\n                ret.parent = ret; // make it look like a simple root node\r\n                return ret;\r\n              }\r\n            };\r\n            return node;\r\n          }\r\n        }, {}, '/proc/self/fd');\r\n      },createStandardStreams:function () {\r\n        // TODO deprecate the old functionality of a single\r\n        // input / output callback and that utilizes FS.createDevice\r\n        // and instead require a unique set of stream ops\r\n  \r\n        // by default, we symlink the standard streams to the\r\n        // default tty devices. however, if the standard streams\r\n        // have been overwritten we create a unique device for\r\n        // them instead.\r\n        if (Module['stdin']) {\r\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdin');\r\n        }\r\n        if (Module['stdout']) {\r\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdout');\r\n        }\r\n        if (Module['stderr']) {\r\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\r\n        } else {\r\n          FS.symlink('/dev/tty1', '/dev/stderr');\r\n        }\r\n  \r\n        // open default streams for the stdin, stdout and stderr devices\r\n        var stdin = FS.open('/dev/stdin', 'r');\r\n        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');\r\n  \r\n        var stdout = FS.open('/dev/stdout', 'w');\r\n        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');\r\n  \r\n        var stderr = FS.open('/dev/stderr', 'w');\r\n        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');\r\n      },ensureErrnoError:function () {\r\n        if (FS.ErrnoError) return;\r\n        FS.ErrnoError = function ErrnoError(errno, node) {\r\n          //Module.printErr(stackTrace()); // useful for debugging\r\n          this.node = node;\r\n          this.setErrno = function(errno) {\r\n            this.errno = errno;\r\n            for (var key in ERRNO_CODES) {\r\n              if (ERRNO_CODES[key] === errno) {\r\n                this.code = key;\r\n                break;\r\n              }\r\n            }\r\n          };\r\n          this.setErrno(errno);\r\n          this.message = ERRNO_MESSAGES[errno];\r\n          // Node.js compatibility: assigning on this.stack fails on Node 4 (but fixed on Node 8)\r\n          if (this.stack) Object.defineProperty(this, \"stack\", { value: (new Error).stack, writable: true });\r\n          if (this.stack) this.stack = demangleAll(this.stack);\r\n        };\r\n        FS.ErrnoError.prototype = new Error();\r\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\r\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\r\n        [ERRNO_CODES.ENOENT].forEach(function(code) {\r\n          FS.genericErrors[code] = new FS.ErrnoError(code);\r\n          FS.genericErrors[code].stack = '<generic error, no stack>';\r\n        });\r\n      },staticInit:function () {\r\n        FS.ensureErrnoError();\r\n  \r\n        FS.nameTable = new Array(4096);\r\n  \r\n        FS.mount(MEMFS, {}, '/');\r\n  \r\n        FS.createDefaultDirectories();\r\n        FS.createDefaultDevices();\r\n        FS.createSpecialDirectories();\r\n  \r\n        FS.filesystems = {\r\n          'MEMFS': MEMFS,\r\n          'IDBFS': IDBFS,\r\n          'NODEFS': NODEFS,\r\n          'WORKERFS': WORKERFS,\r\n        };\r\n      },init:function (input, output, error) {\r\n        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\r\n        FS.init.initialized = true;\r\n  \r\n        FS.ensureErrnoError();\r\n  \r\n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n        Module['stdin'] = input || Module['stdin'];\r\n        Module['stdout'] = output || Module['stdout'];\r\n        Module['stderr'] = error || Module['stderr'];\r\n  \r\n        FS.createStandardStreams();\r\n      },quit:function () {\r\n        FS.init.initialized = false;\r\n        // force-flush all streams, so we get musl std streams printed out\r\n        var fflush = Module['_fflush'];\r\n        if (fflush) fflush(0);\r\n        // close all of our streams\r\n        for (var i = 0; i < FS.streams.length; i++) {\r\n          var stream = FS.streams[i];\r\n          if (!stream) {\r\n            continue;\r\n          }\r\n          FS.close(stream);\r\n        }\r\n      },getMode:function (canRead, canWrite) {\r\n        var mode = 0;\r\n        if (canRead) mode |= 292 | 73;\r\n        if (canWrite) mode |= 146;\r\n        return mode;\r\n      },joinPath:function (parts, forceRelative) {\r\n        var path = PATH.join.apply(null, parts);\r\n        if (forceRelative && path[0] == '/') path = path.substr(1);\r\n        return path;\r\n      },absolutePath:function (relative, base) {\r\n        return PATH.resolve(base, relative);\r\n      },standardizePath:function (path) {\r\n        return PATH.normalize(path);\r\n      },findObject:function (path, dontResolveLastLink) {\r\n        var ret = FS.analyzePath(path, dontResolveLastLink);\r\n        if (ret.exists) {\r\n          return ret.object;\r\n        } else {\r\n          ___setErrNo(ret.error);\r\n          return null;\r\n        }\r\n      },analyzePath:function (path, dontResolveLastLink) {\r\n        // operate from within the context of the symlink's target\r\n        try {\r\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          path = lookup.path;\r\n        } catch (e) {\r\n        }\r\n        var ret = {\r\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\r\n          parentExists: false, parentPath: null, parentObject: null\r\n        };\r\n        try {\r\n          var lookup = FS.lookupPath(path, { parent: true });\r\n          ret.parentExists = true;\r\n          ret.parentPath = lookup.path;\r\n          ret.parentObject = lookup.node;\r\n          ret.name = PATH.basename(path);\r\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          ret.exists = true;\r\n          ret.path = lookup.path;\r\n          ret.object = lookup.node;\r\n          ret.name = lookup.node.name;\r\n          ret.isRoot = lookup.path === '/';\r\n        } catch (e) {\r\n          ret.error = e.errno;\r\n        };\r\n        return ret;\r\n      },createFolder:function (parent, name, canRead, canWrite) {\r\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS.getMode(canRead, canWrite);\r\n        return FS.mkdir(path, mode);\r\n      },createPath:function (parent, path, canRead, canWrite) {\r\n        parent = typeof parent === 'string' ? parent : FS.getPath(parent);\r\n        var parts = path.split('/').reverse();\r\n        while (parts.length) {\r\n          var part = parts.pop();\r\n          if (!part) continue;\r\n          var current = PATH.join2(parent, part);\r\n          try {\r\n            FS.mkdir(current);\r\n          } catch (e) {\r\n            // ignore EEXIST\r\n          }\r\n          parent = current;\r\n        }\r\n        return current;\r\n      },createFile:function (parent, name, properties, canRead, canWrite) {\r\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS.getMode(canRead, canWrite);\r\n        return FS.create(path, mode);\r\n      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {\r\n        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;\r\n        var mode = FS.getMode(canRead, canWrite);\r\n        var node = FS.create(path, mode);\r\n        if (data) {\r\n          if (typeof data === 'string') {\r\n            var arr = new Array(data.length);\r\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n            data = arr;\r\n          }\r\n          // make sure we can write to the file\r\n          FS.chmod(node, mode | 146);\r\n          var stream = FS.open(node, 'w');\r\n          FS.write(stream, data, 0, data.length, 0, canOwn);\r\n          FS.close(stream);\r\n          FS.chmod(node, mode);\r\n        }\r\n        return node;\r\n      },createDevice:function (parent, name, input, output) {\r\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS.getMode(!!input, !!output);\r\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\r\n        var dev = FS.makedev(FS.createDevice.major++, 0);\r\n        // Create a fake device that a set of stream ops to emulate\r\n        // the old behavior.\r\n        FS.registerDevice(dev, {\r\n          open: function(stream) {\r\n            stream.seekable = false;\r\n          },\r\n          close: function(stream) {\r\n            // flush any pending line data\r\n            if (output && output.buffer && output.buffer.length) {\r\n              output(10);\r\n            }\r\n          },\r\n          read: function(stream, buffer, offset, length, pos /* ignored */) {\r\n            var bytesRead = 0;\r\n            for (var i = 0; i < length; i++) {\r\n              var result;\r\n              try {\r\n                result = input();\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n              }\r\n              if (result === undefined && bytesRead === 0) {\r\n                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);\r\n              }\r\n              if (result === null || result === undefined) break;\r\n              bytesRead++;\r\n              buffer[offset+i] = result;\r\n            }\r\n            if (bytesRead) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return bytesRead;\r\n          },\r\n          write: function(stream, buffer, offset, length, pos) {\r\n            for (var i = 0; i < length; i++) {\r\n              try {\r\n                output(buffer[offset+i]);\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n              }\r\n            }\r\n            if (length) {\r\n              stream.node.timestamp = Date.now();\r\n            }\r\n            return i;\r\n          }\r\n        });\r\n        return FS.mkdev(path, mode, dev);\r\n      },createLink:function (parent, name, target, canRead, canWrite) {\r\n        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);\r\n        return FS.symlink(target, path);\r\n      },forceLoadFile:function (obj) {\r\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n        var success = true;\r\n        if (typeof XMLHttpRequest !== 'undefined') {\r\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n        } else if (Module['read']) {\r\n          // Command-line.\r\n          try {\r\n            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as\r\n            //          read() will try to parse UTF8.\r\n            obj.contents = intArrayFromString(Module['read'](obj.url), true);\r\n            obj.usedBytes = obj.contents.length;\r\n          } catch (e) {\r\n            success = false;\r\n          }\r\n        } else {\r\n          throw new Error('Cannot load without read() or XMLHttpRequest.');\r\n        }\r\n        if (!success) ___setErrNo(ERRNO_CODES.EIO);\r\n        return success;\r\n      },createLazyFile:function (parent, name, url, canRead, canWrite) {\r\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.\r\n        function LazyUint8Array() {\r\n          this.lengthKnown = false;\r\n          this.chunks = []; // Loaded chunks. Index is the chunk number\r\n        }\r\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\r\n          if (idx > this.length-1 || idx < 0) {\r\n            return undefined;\r\n          }\r\n          var chunkOffset = idx % this.chunkSize;\r\n          var chunkNum = (idx / this.chunkSize)|0;\r\n          return this.getter(chunkNum)[chunkOffset];\r\n        }\r\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\r\n          this.getter = getter;\r\n        }\r\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\r\n          // Find length\r\n          var xhr = new XMLHttpRequest();\r\n          xhr.open('HEAD', url, false);\r\n          xhr.send(null);\r\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n          var header;\r\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n  \r\n          var chunkSize = 1024*1024; // Chunk size in bytes\r\n  \r\n          if (!hasByteServing) chunkSize = datalength;\r\n  \r\n          // Function to get a range from the remote URL.\r\n          var doXHR = (function(from, to) {\r\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n            if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n  \r\n            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open('GET', url, false);\r\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n  \r\n            // Some hints to the browser that we want binary data.\r\n            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';\r\n            if (xhr.overrideMimeType) {\r\n              xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n            }\r\n  \r\n            xhr.send(null);\r\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n            if (xhr.response !== undefined) {\r\n              return new Uint8Array(xhr.response || []);\r\n            } else {\r\n              return intArrayFromString(xhr.responseText || '', true);\r\n            }\r\n          });\r\n          var lazyArray = this;\r\n          lazyArray.setDataGetter(function(chunkNum) {\r\n            var start = chunkNum * chunkSize;\r\n            var end = (chunkNum+1) * chunkSize - 1; // including this byte\r\n            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\r\n            if (typeof(lazyArray.chunks[chunkNum]) === \"undefined\") {\r\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n            }\r\n            if (typeof(lazyArray.chunks[chunkNum]) === \"undefined\") throw new Error(\"doXHR failed!\");\r\n            return lazyArray.chunks[chunkNum];\r\n          });\r\n  \r\n          if (usesGzip || !datalength) {\r\n            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\r\n            datalength = this.getter(0).length;\r\n            chunkSize = datalength;\r\n            console.log(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n          }\r\n  \r\n          this._length = datalength;\r\n          this._chunkSize = chunkSize;\r\n          this.lengthKnown = true;\r\n        }\r\n        if (typeof XMLHttpRequest !== 'undefined') {\r\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\r\n          var lazyArray = new LazyUint8Array();\r\n          Object.defineProperties(lazyArray, {\r\n            length: {\r\n              get: function() {\r\n                if(!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._length;\r\n              }\r\n            },\r\n            chunkSize: {\r\n              get: function() {\r\n                if(!this.lengthKnown) {\r\n                  this.cacheLength();\r\n                }\r\n                return this._chunkSize;\r\n              }\r\n            }\r\n          });\r\n  \r\n          var properties = { isDevice: false, contents: lazyArray };\r\n        } else {\r\n          var properties = { isDevice: false, url: url };\r\n        }\r\n  \r\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n        // This is a total hack, but I want to get this lazy file code out of the\r\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n        // be its own thin LAZYFS proxying calls to MEMFS.\r\n        if (properties.contents) {\r\n          node.contents = properties.contents;\r\n        } else if (properties.url) {\r\n          node.contents = null;\r\n          node.url = properties.url;\r\n        }\r\n        // Add a function that defers querying the file size until it is asked the first time.\r\n        Object.defineProperties(node, {\r\n          usedBytes: {\r\n            get: function() { return this.contents.length; }\r\n          }\r\n        });\r\n        // override each stream op with one that tries to force load the lazy file first\r\n        var stream_ops = {};\r\n        var keys = Object.keys(node.stream_ops);\r\n        keys.forEach(function(key) {\r\n          var fn = node.stream_ops[key];\r\n          stream_ops[key] = function forceLoadLazyFile() {\r\n            if (!FS.forceLoadFile(node)) {\r\n              throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n            }\r\n            return fn.apply(null, arguments);\r\n          };\r\n        });\r\n        // use a custom read function\r\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\r\n          if (!FS.forceLoadFile(node)) {\r\n            throw new FS.ErrnoError(ERRNO_CODES.EIO);\r\n          }\r\n          var contents = stream.node.contents;\r\n          if (position >= contents.length)\r\n            return 0;\r\n          var size = Math.min(contents.length - position, length);\r\n          assert(size >= 0);\r\n          if (contents.slice) { // normal array\r\n            for (var i = 0; i < size; i++) {\r\n              buffer[offset + i] = contents[position + i];\r\n            }\r\n          } else {\r\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\r\n              buffer[offset + i] = contents.get(position + i);\r\n            }\r\n          }\r\n          return size;\r\n        };\r\n        node.stream_ops = stream_ops;\r\n        return node;\r\n      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\r\n        Browser.init(); // XXX perhaps this method should move onto Browser?\r\n        // TODO we should allow people to just pass in a complete filename instead\r\n        // of parent and name being that we just join them anyways\r\n        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;\r\n        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname\r\n        function processData(byteArray) {\r\n          function finish(byteArray) {\r\n            if (preFinish) preFinish();\r\n            if (!dontCreateFile) {\r\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n            }\r\n            if (onload) onload();\r\n            removeRunDependency(dep);\r\n          }\r\n          var handled = false;\r\n          Module['preloadPlugins'].forEach(function(plugin) {\r\n            if (handled) return;\r\n            if (plugin['canHandle'](fullname)) {\r\n              plugin['handle'](byteArray, fullname, finish, function() {\r\n                if (onerror) onerror();\r\n                removeRunDependency(dep);\r\n              });\r\n              handled = true;\r\n            }\r\n          });\r\n          if (!handled) finish(byteArray);\r\n        }\r\n        addRunDependency(dep);\r\n        if (typeof url == 'string') {\r\n          Browser.asyncLoad(url, function(byteArray) {\r\n            processData(byteArray);\r\n          }, onerror);\r\n        } else {\r\n          processData(url);\r\n        }\r\n      },indexedDB:function () {\r\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\r\n      },DB_NAME:function () {\r\n        return 'EM_FS_' + window.location.pathname;\r\n      },DB_VERSION:20,DB_STORE_NAME:\"FILE_DATA\",saveFilesToDB:function (paths, onload, onerror) {\r\n        onload = onload || function(){};\r\n        onerror = onerror || function(){};\r\n        var indexedDB = FS.indexedDB();\r\n        try {\r\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n        } catch (e) {\r\n          return onerror(e);\r\n        }\r\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\r\n          console.log('creating db');\r\n          var db = openRequest.result;\r\n          db.createObjectStore(FS.DB_STORE_NAME);\r\n        };\r\n        openRequest.onsuccess = function openRequest_onsuccess() {\r\n          var db = openRequest.result;\r\n          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');\r\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n          var ok = 0, fail = 0, total = paths.length;\r\n          function finish() {\r\n            if (fail == 0) onload(); else onerror();\r\n          }\r\n          paths.forEach(function(path) {\r\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\r\n            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };\r\n            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };\r\n          });\r\n          transaction.onerror = onerror;\r\n        };\r\n        openRequest.onerror = onerror;\r\n      },loadFilesFromDB:function (paths, onload, onerror) {\r\n        onload = onload || function(){};\r\n        onerror = onerror || function(){};\r\n        var indexedDB = FS.indexedDB();\r\n        try {\r\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\r\n        } catch (e) {\r\n          return onerror(e);\r\n        }\r\n        openRequest.onupgradeneeded = onerror; // no database to load from\r\n        openRequest.onsuccess = function openRequest_onsuccess() {\r\n          var db = openRequest.result;\r\n          try {\r\n            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');\r\n          } catch(e) {\r\n            onerror(e);\r\n            return;\r\n          }\r\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\r\n          var ok = 0, fail = 0, total = paths.length;\r\n          function finish() {\r\n            if (fail == 0) onload(); else onerror();\r\n          }\r\n          paths.forEach(function(path) {\r\n            var getRequest = files.get(path);\r\n            getRequest.onsuccess = function getRequest_onsuccess() {\r\n              if (FS.analyzePath(path).exists) {\r\n                FS.unlink(path);\r\n              }\r\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\r\n              ok++;\r\n              if (ok + fail == total) finish();\r\n            };\r\n            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };\r\n          });\r\n          transaction.onerror = onerror;\r\n        };\r\n        openRequest.onerror = onerror;\r\n      }};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function (dirfd, path) {\r\n        if (path[0] !== '/') {\r\n          // relative path\r\n          var dir;\r\n          if (dirfd === -100) {\r\n            dir = FS.cwd();\r\n          } else {\r\n            var dirstream = FS.getStream(dirfd);\r\n            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n            dir = dirstream.path;\r\n          }\r\n          path = PATH.join2(dir, path);\r\n        }\r\n        return path;\r\n      },doStat:function (func, path, buf) {\r\n        try {\r\n          var stat = func(path);\r\n        } catch (e) {\r\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\r\n            // an error occurred while trying to look up the path; we should just report ENOTDIR\r\n            return -ERRNO_CODES.ENOTDIR;\r\n          }\r\n          throw e;\r\n        }\r\n        HEAP32[((buf)>>2)]=stat.dev;\r\n        HEAP32[(((buf)+(4))>>2)]=0;\r\n        HEAP32[(((buf)+(8))>>2)]=stat.ino;\r\n        HEAP32[(((buf)+(12))>>2)]=stat.mode;\r\n        HEAP32[(((buf)+(16))>>2)]=stat.nlink;\r\n        HEAP32[(((buf)+(20))>>2)]=stat.uid;\r\n        HEAP32[(((buf)+(24))>>2)]=stat.gid;\r\n        HEAP32[(((buf)+(28))>>2)]=stat.rdev;\r\n        HEAP32[(((buf)+(32))>>2)]=0;\r\n        HEAP32[(((buf)+(36))>>2)]=stat.size;\r\n        HEAP32[(((buf)+(40))>>2)]=4096;\r\n        HEAP32[(((buf)+(44))>>2)]=stat.blocks;\r\n        HEAP32[(((buf)+(48))>>2)]=(stat.atime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(52))>>2)]=0;\r\n        HEAP32[(((buf)+(56))>>2)]=(stat.mtime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(60))>>2)]=0;\r\n        HEAP32[(((buf)+(64))>>2)]=(stat.ctime.getTime() / 1000)|0;\r\n        HEAP32[(((buf)+(68))>>2)]=0;\r\n        HEAP32[(((buf)+(72))>>2)]=stat.ino;\r\n        return 0;\r\n      },doMsync:function (addr, stream, len, flags) {\r\n        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));\r\n        FS.msync(stream, buffer, 0, len, flags);\r\n      },doMkdir:function (path, mode) {\r\n        // remove a trailing slash, if one - /a/b/ has basename of '', but\r\n        // we want to create b in the context of this function\r\n        path = PATH.normalize(path);\r\n        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);\r\n        FS.mkdir(path, mode, 0);\r\n        return 0;\r\n      },doMknod:function (path, mode, dev) {\r\n        // we don't want this in the JS API as it uses mknod to create all nodes.\r\n        switch (mode & 61440) {\r\n          case 32768:\r\n          case 8192:\r\n          case 24576:\r\n          case 4096:\r\n          case 49152:\r\n            break;\r\n          default: return -ERRNO_CODES.EINVAL;\r\n        }\r\n        FS.mknod(path, mode, dev);\r\n        return 0;\r\n      },doReadlink:function (path, buf, bufsize) {\r\n        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;\r\n        var ret = FS.readlink(path);\r\n  \r\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\r\n        var endChar = HEAP8[buf+len];\r\n        stringToUTF8(ret, buf, bufsize+1);\r\n        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)\r\n        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.\r\n        HEAP8[buf+len] = endChar;\r\n  \r\n        return len;\r\n      },doAccess:function (path, amode) {\r\n        if (amode & ~7) {\r\n          // need a valid mode\r\n          return -ERRNO_CODES.EINVAL;\r\n        }\r\n        var node;\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        node = lookup.node;\r\n        var perms = '';\r\n        if (amode & 4) perms += 'r';\r\n        if (amode & 2) perms += 'w';\r\n        if (amode & 1) perms += 'x';\r\n        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {\r\n          return -ERRNO_CODES.EACCES;\r\n        }\r\n        return 0;\r\n      },doDup:function (path, flags, suggestFD) {\r\n        var suggest = FS.getStream(suggestFD);\r\n        if (suggest) FS.close(suggest);\r\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\r\n      },doReadv:function (stream, iov, iovcnt, offset) {\r\n        var ret = 0;\r\n        for (var i = 0; i < iovcnt; i++) {\r\n          var ptr = HEAP32[(((iov)+(i*8))>>2)];\r\n          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\r\n          var curr = FS.read(stream, HEAP8,ptr, len, offset);\r\n          if (curr < 0) return -1;\r\n          ret += curr;\r\n          if (curr < len) break; // nothing more to read\r\n        }\r\n        return ret;\r\n      },doWritev:function (stream, iov, iovcnt, offset) {\r\n        var ret = 0;\r\n        for (var i = 0; i < iovcnt; i++) {\r\n          var ptr = HEAP32[(((iov)+(i*8))>>2)];\r\n          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\r\n          var curr = FS.write(stream, HEAP8,ptr, len, offset);\r\n          if (curr < 0) return -1;\r\n          ret += curr;\r\n        }\r\n        return ret;\r\n      },varargs:0,get:function (varargs) {\r\n        SYSCALLS.varargs += 4;\r\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\r\n        return ret;\r\n      },getStr:function () {\r\n        var ret = Pointer_stringify(SYSCALLS.get());\r\n        return ret;\r\n      },getStreamFromFD:function () {\r\n        var stream = FS.getStream(SYSCALLS.get());\r\n        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        return stream;\r\n      },getSocketFromFD:function () {\r\n        var socket = SOCKFS.getSocket(SYSCALLS.get());\r\n        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);\r\n        return socket;\r\n      },getSocketAddress:function (allowNull) {\r\n        var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();\r\n        if (allowNull && addrp === 0) return null;\r\n        var info = __read_sockaddr(addrp, addrlen);\r\n        if (info.errno) throw new FS.ErrnoError(info.errno);\r\n        info.addr = DNS.lookup_addr(info.addr) || info.addr;\r\n        return info;\r\n      },get64:function () {\r\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\r\n        if (low >= 0) assert(high === 0);\r\n        else assert(high === -1);\r\n        return low;\r\n      },getZero:function () {\r\n        assert(SYSCALLS.get() === 0);\r\n      }};function ___syscall10(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // unlink\r\n      var path = SYSCALLS.getStr();\r\n      FS.unlink(path);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // llseek\r\n      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();\r\n      // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\r\n      var offset = offset_low;\r\n      FS.llseek(stream, offset, whence);\r\n      HEAP32[((result)>>2)]=stream.position;\r\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall145(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // readv\r\n      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\r\n      return SYSCALLS.doReadv(stream, iov, iovcnt);\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // writev\r\n      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();\r\n      return SYSCALLS.doWritev(stream, iov, iovcnt);\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall196(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // SYS_lstat64\r\n      var path = SYSCALLS.getStr(), buf = SYSCALLS.get();\r\n      return SYSCALLS.doStat(FS.lstat, path, buf);\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // fcntl64\r\n      var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();\r\n      switch (cmd) {\r\n        case 0: {\r\n          var arg = SYSCALLS.get();\r\n          if (arg < 0) {\r\n            return -ERRNO_CODES.EINVAL;\r\n          }\r\n          var newStream;\r\n          newStream = FS.open(stream.path, stream.flags, 0, arg);\r\n          return newStream.fd;\r\n        }\r\n        case 1:\r\n        case 2:\r\n          return 0;  // FD_CLOEXEC makes no sense for a single process.\r\n        case 3:\r\n          return stream.flags;\r\n        case 4: {\r\n          var arg = SYSCALLS.get();\r\n          stream.flags |= arg;\r\n          return 0;\r\n        }\r\n        case 12:\r\n        case 12: {\r\n          var arg = SYSCALLS.get();\r\n          var offset = 0;\r\n          // We're always unlocked.\r\n          HEAP16[(((arg)+(offset))>>1)]=2;\r\n          return 0;\r\n        }\r\n        case 13:\r\n        case 14:\r\n        case 13:\r\n        case 14:\r\n          return 0; // Pretend that the locking is successful.\r\n        case 16:\r\n        case 8:\r\n          return -ERRNO_CODES.EINVAL; // These are for sockets. We don't have them fully implemented yet.\r\n        case 9:\r\n          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.\r\n          ___setErrNo(ERRNO_CODES.EINVAL);\r\n          return -1;\r\n        default: {\r\n          return -ERRNO_CODES.EINVAL;\r\n        }\r\n      }\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall330(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // dup3\r\n      var old = SYSCALLS.getStreamFromFD(), suggestFD = SYSCALLS.get(), flags = SYSCALLS.get();\r\n      assert(!flags);\r\n      if (old.fd === suggestFD) return -ERRNO_CODES.EINVAL;\r\n      return SYSCALLS.doDup(old.path, old.flags, suggestFD);\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall38(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // rename\r\n      var old_path = SYSCALLS.getStr(), new_path = SYSCALLS.getStr();\r\n      FS.rename(old_path, new_path);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall4(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // write\r\n      var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get();\r\n      return FS.write(stream, HEAP8,buf, count);\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall40(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // rmdir\r\n      var path = SYSCALLS.getStr();\r\n      FS.rmdir(path);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // open\r\n      var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get() // optional TODO\r\n      var stream = FS.open(pathname, flags, mode);\r\n      return stream.fd;\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // ioctl\r\n      var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();\r\n      switch (op) {\r\n        case 21509:\r\n        case 21505: {\r\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n          return 0;\r\n        }\r\n        case 21510:\r\n        case 21511:\r\n        case 21512:\r\n        case 21506:\r\n        case 21507:\r\n        case 21508: {\r\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n          return 0; // no-op, not actually adjusting terminal settings\r\n        }\r\n        case 21519: {\r\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n          var argp = SYSCALLS.get();\r\n          HEAP32[((argp)>>2)]=0;\r\n          return 0;\r\n        }\r\n        case 21520: {\r\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n          return -ERRNO_CODES.EINVAL; // not supported\r\n        }\r\n        case 21531: {\r\n          var argp = SYSCALLS.get();\r\n          return FS.ioctl(stream, op, argp);\r\n        }\r\n        case 21523: {\r\n          // TODO: in theory we should write to the winsize struct that gets\r\n          // passed in, but for now musl doesn't read anything on it\r\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n          return 0;\r\n        }\r\n        case 21524: {\r\n          // TODO: technically, this ioctl call should change the window size.\r\n          // but, since emscripten doesn't have any concept of a terminal window\r\n          // yet, we'll just silently throw it away as we do TIOCGWINSZ\r\n          if (!stream.tty) return -ERRNO_CODES.ENOTTY;\r\n          return 0;\r\n        }\r\n        default: abort('bad ioctl syscall ' + op);\r\n      }\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // close\r\n      var stream = SYSCALLS.getStreamFromFD();\r\n      FS.close(stream);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall63(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // dup2\r\n      var old = SYSCALLS.getStreamFromFD(), suggestFD = SYSCALLS.get();\r\n      if (old.fd === suggestFD) return suggestFD;\r\n      return SYSCALLS.doDup(old.path, old.flags, suggestFD);\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___syscall91(which, varargs) {SYSCALLS.varargs = varargs;\r\n  try {\r\n   // munmap\r\n      var addr = SYSCALLS.get(), len = SYSCALLS.get();\r\n      // TODO: support unmmap'ing parts of allocations\r\n      var info = SYSCALLS.mappings[addr];\r\n      if (!info) return 0;\r\n      if (len === info.len) {\r\n        var stream = FS.getStream(info.fd);\r\n        SYSCALLS.doMsync(addr, stream, len, info.flags)\r\n        FS.munmap(stream);\r\n        SYSCALLS.mappings[addr] = null;\r\n        if (info.allocated) {\r\n          _free(info.malloc);\r\n        }\r\n      }\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\r\n    return -e.errno;\r\n  }\r\n  }\r\n\r\n  function ___unlock() {}\r\n\r\n  function _abort() {\r\n      Module['abort']();\r\n    }\r\n\r\n  function _clock() {\r\n      if (_clock.start === undefined) _clock.start = Date.now();\r\n      return ((Date.now() - _clock.start) * (1000000 / 1000))|0;\r\n    }\r\n\r\n  function _difftime(time1, time0) {\r\n      return time1 - time0;\r\n    }\r\n\r\n  function _dladdr(addr, info) {\r\n      // report all function pointers as coming from this program itself XXX not really correct in any way\r\n      var fname = allocate(intArrayFromString(Module['thisProgram'] || './this.program'), 'i8', ALLOC_NORMAL); // XXX leak\r\n      HEAP32[((info)>>2)]=fname;\r\n      HEAP32[(((info)+(4))>>2)]=0;\r\n      HEAP32[(((info)+(8))>>2)]=0;\r\n      HEAP32[(((info)+(12))>>2)]=0;\r\n      return 1;\r\n    }\r\n\r\n  var _emscripten_asm_const_int=true;\r\n\r\n  \r\n  function __exit(status) {\r\n      // void _exit(int status);\r\n      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html\r\n      Module['exit'](status);\r\n    }function _exit(status) {\r\n      __exit(status);\r\n    }\r\n\r\n  \r\n  \r\n  \r\n  \r\n  var _environ=STATICTOP; STATICTOP += 16;;var ___environ=_environ;function ___buildEnvironment(env) {\r\n      // WARNING: Arbitrary limit!\r\n      var MAX_ENV_VALUES = 64;\r\n      var TOTAL_ENV_SIZE = 1024;\r\n  \r\n      // Statically allocate memory for the environment.\r\n      var poolPtr;\r\n      var envPtr;\r\n      if (!___buildEnvironment.called) {\r\n        ___buildEnvironment.called = true;\r\n        // Set default values. Use string keys for Closure Compiler compatibility.\r\n        ENV['USER'] = ENV['LOGNAME'] = 'web_user';\r\n        ENV['PATH'] = '/';\r\n        ENV['PWD'] = '/';\r\n        ENV['HOME'] = '/home/web_user';\r\n        ENV['LANG'] = 'C.UTF-8';\r\n        ENV['_'] = Module['thisProgram'];\r\n        // Allocate memory.\r\n        poolPtr = staticAlloc(TOTAL_ENV_SIZE);\r\n        envPtr = staticAlloc(MAX_ENV_VALUES * 4);\r\n        HEAP32[((envPtr)>>2)]=poolPtr;\r\n        HEAP32[((_environ)>>2)]=envPtr;\r\n      } else {\r\n        envPtr = HEAP32[((_environ)>>2)];\r\n        poolPtr = HEAP32[((envPtr)>>2)];\r\n      }\r\n  \r\n      // Collect key=value lines.\r\n      var strings = [];\r\n      var totalSize = 0;\r\n      for (var key in env) {\r\n        if (typeof env[key] === 'string') {\r\n          var line = key + '=' + env[key];\r\n          strings.push(line);\r\n          totalSize += line.length;\r\n        }\r\n      }\r\n      if (totalSize > TOTAL_ENV_SIZE) {\r\n        throw new Error('Environment size exceeded TOTAL_ENV_SIZE!');\r\n      }\r\n  \r\n      // Make new.\r\n      var ptrSize = 4;\r\n      for (var i = 0; i < strings.length; i++) {\r\n        var line = strings[i];\r\n        writeAsciiToMemory(line, poolPtr);\r\n        HEAP32[(((envPtr)+(i * ptrSize))>>2)]=poolPtr;\r\n        poolPtr += line.length + 1;\r\n      }\r\n      HEAP32[(((envPtr)+(strings.length * ptrSize))>>2)]=0;\r\n    }var ENV={};function _getenv(name) {\r\n      // char *getenv(const char *name);\r\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/getenv.html\r\n      if (name === 0) return 0;\r\n      name = Pointer_stringify(name);\r\n      if (!ENV.hasOwnProperty(name)) return 0;\r\n  \r\n      if (_getenv.ret) _free(_getenv.ret);\r\n      _getenv.ret = allocateUTF8(ENV[name]);\r\n      return _getenv.ret;\r\n    }\r\n\r\n  \r\n  var ___tm_current=STATICTOP; STATICTOP += 48;;\r\n  \r\n  \r\n  var ___tm_timezone=allocate(intArrayFromString(\"GMT\"), \"i8\", ALLOC_STATIC);function _gmtime_r(time, tmPtr) {\r\n      var date = new Date(HEAP32[((time)>>2)]*1000);\r\n      HEAP32[((tmPtr)>>2)]=date.getUTCSeconds();\r\n      HEAP32[(((tmPtr)+(4))>>2)]=date.getUTCMinutes();\r\n      HEAP32[(((tmPtr)+(8))>>2)]=date.getUTCHours();\r\n      HEAP32[(((tmPtr)+(12))>>2)]=date.getUTCDate();\r\n      HEAP32[(((tmPtr)+(16))>>2)]=date.getUTCMonth();\r\n      HEAP32[(((tmPtr)+(20))>>2)]=date.getUTCFullYear()-1900;\r\n      HEAP32[(((tmPtr)+(24))>>2)]=date.getUTCDay();\r\n      HEAP32[(((tmPtr)+(36))>>2)]=0;\r\n      HEAP32[(((tmPtr)+(32))>>2)]=0;\r\n      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);\r\n      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;\r\n      HEAP32[(((tmPtr)+(28))>>2)]=yday;\r\n      HEAP32[(((tmPtr)+(40))>>2)]=___tm_timezone;\r\n  \r\n      return tmPtr;\r\n    }function _gmtime(time) {\r\n      return _gmtime_r(time, ___tm_current);\r\n    }\r\n\r\n   \r\n\r\n   \r\n\r\n  var _llvm_ctlz_i32=true;\r\n\r\n  var _llvm_nacl_atomic_cmpxchg_i32=undefined;\r\n\r\n  var _llvm_nacl_atomic_cmpxchg_i8=undefined;\r\n\r\n  var _llvm_pow_f64=Math_pow;\r\n\r\n  function _llvm_trap() {\r\n      abort('trap!');\r\n    }\r\n\r\n  \r\n  \r\n  \r\n  var _tzname=STATICTOP; STATICTOP += 16;;\r\n  \r\n  var _daylight=STATICTOP; STATICTOP += 16;;\r\n  \r\n  var _timezone=STATICTOP; STATICTOP += 16;;function _tzset() {\r\n      // TODO: Use (malleable) environment variables instead of system settings.\r\n      if (_tzset.called) return;\r\n      _tzset.called = true;\r\n  \r\n      // timezone is specified as seconds west of UTC (\"The external variable\r\n      // `timezone` shall be set to the difference, in seconds, between\r\n      // Coordinated Universal Time (UTC) and local standard time.\"), the same\r\n      // as returned by getTimezoneOffset().\r\n      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\r\n      HEAP32[((_timezone)>>2)]=(new Date()).getTimezoneOffset() * 60;\r\n  \r\n      var winter = new Date(2000, 0, 1);\r\n      var summer = new Date(2000, 6, 1);\r\n      HEAP32[((_daylight)>>2)]=Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());\r\n  \r\n      function extractZone(date) {\r\n        var match = date.toTimeString().match(/\\(([A-Za-z ]+)\\)$/);\r\n        return match ? match[1] : \"GMT\";\r\n      };\r\n      var winterName = extractZone(winter);\r\n      var summerName = extractZone(summer);\r\n      var winterNamePtr = allocate(intArrayFromString(winterName), 'i8', ALLOC_NORMAL);\r\n      var summerNamePtr = allocate(intArrayFromString(summerName), 'i8', ALLOC_NORMAL);\r\n      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {\r\n        // Northern hemisphere\r\n        HEAP32[((_tzname)>>2)]=winterNamePtr;\r\n        HEAP32[(((_tzname)+(4))>>2)]=summerNamePtr;\r\n      } else {\r\n        HEAP32[((_tzname)>>2)]=summerNamePtr;\r\n        HEAP32[(((_tzname)+(4))>>2)]=winterNamePtr;\r\n      }\r\n    }function _localtime_r(time, tmPtr) {\r\n      _tzset();\r\n      var date = new Date(HEAP32[((time)>>2)]*1000);\r\n      HEAP32[((tmPtr)>>2)]=date.getSeconds();\r\n      HEAP32[(((tmPtr)+(4))>>2)]=date.getMinutes();\r\n      HEAP32[(((tmPtr)+(8))>>2)]=date.getHours();\r\n      HEAP32[(((tmPtr)+(12))>>2)]=date.getDate();\r\n      HEAP32[(((tmPtr)+(16))>>2)]=date.getMonth();\r\n      HEAP32[(((tmPtr)+(20))>>2)]=date.getFullYear()-1900;\r\n      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();\r\n  \r\n      var start = new Date(date.getFullYear(), 0, 1);\r\n      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;\r\n      HEAP32[(((tmPtr)+(28))>>2)]=yday;\r\n      HEAP32[(((tmPtr)+(36))>>2)]=-(date.getTimezoneOffset() * 60);\r\n  \r\n      // Attention: DST is in December in South, and some regions don't have DST at all.\r\n      var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();\r\n      var winterOffset = start.getTimezoneOffset();\r\n      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;\r\n      HEAP32[(((tmPtr)+(32))>>2)]=dst;\r\n  \r\n      var zonePtr = HEAP32[(((_tzname)+(dst ? 4 : 0))>>2)];\r\n      HEAP32[(((tmPtr)+(40))>>2)]=zonePtr;\r\n  \r\n      return tmPtr;\r\n    }function _localtime(time) {\r\n      return _localtime_r(time, ___tm_current);\r\n    }\r\n\r\n  \r\n   \r\n  \r\n   function _longjmp(env, value) {\r\n      Module['setThrew'](env, value || 1);\r\n      throw 'longjmp';\r\n    }\r\n\r\n  \r\n  function _emscripten_memcpy_big(dest, src, num) {\r\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\r\n      return dest;\r\n    } \r\n\r\n   \r\n\r\n  function _mktime(tmPtr) {\r\n      _tzset();\r\n      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,\r\n                          HEAP32[(((tmPtr)+(16))>>2)],\r\n                          HEAP32[(((tmPtr)+(12))>>2)],\r\n                          HEAP32[(((tmPtr)+(8))>>2)],\r\n                          HEAP32[(((tmPtr)+(4))>>2)],\r\n                          HEAP32[((tmPtr)>>2)],\r\n                          0);\r\n  \r\n      // There's an ambiguous hour when the time goes back; the tm_isdst field is\r\n      // used to disambiguate it.  Date() basically guesses, so we fix it up if it\r\n      // guessed wrong, or fill in tm_isdst with the guess if it's -1.\r\n      var dst = HEAP32[(((tmPtr)+(32))>>2)];\r\n      var guessedOffset = date.getTimezoneOffset();\r\n      var start = new Date(date.getFullYear(), 0, 1);\r\n      var summerOffset = new Date(2000, 6, 1).getTimezoneOffset();\r\n      var winterOffset = start.getTimezoneOffset();\r\n      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South\r\n      if (dst < 0) {\r\n        // Attention: some regions don't have DST at all.\r\n        HEAP32[(((tmPtr)+(32))>>2)]=Number(summerOffset != winterOffset && dstOffset == guessedOffset);\r\n      } else if ((dst > 0) != (dstOffset == guessedOffset)) {\r\n        var nonDstOffset = Math.max(winterOffset, summerOffset);\r\n        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;\r\n        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.\r\n        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);\r\n      }\r\n  \r\n      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();\r\n      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;\r\n      HEAP32[(((tmPtr)+(28))>>2)]=yday;\r\n  \r\n      return (date.getTime() / 1000)|0;\r\n    }\r\n\r\n  function _pthread_cond_destroy() { return 0; }\r\n\r\n  function _pthread_cond_init() { return 0; }\r\n\r\n  function _pthread_condattr_destroy() { return 0; }\r\n\r\n  function _pthread_condattr_init() { return 0; }\r\n\r\n  function _pthread_condattr_setclock() { return 0; }\r\n\r\n  \r\n  var PTHREAD_SPECIFIC={};function _pthread_getspecific(key) {\r\n      return PTHREAD_SPECIFIC[key] || 0;\r\n    }\r\n\r\n  \r\n  var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key, destructor) {\r\n      if (key == 0) {\r\n        return ERRNO_CODES.EINVAL;\r\n      }\r\n      HEAP32[((key)>>2)]=PTHREAD_SPECIFIC_NEXT_KEY;\r\n      // values start at 0\r\n      PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;\r\n      PTHREAD_SPECIFIC_NEXT_KEY++;\r\n      return 0;\r\n    }\r\n\r\n  function _pthread_key_delete(key) {\r\n      if (key in PTHREAD_SPECIFIC) {\r\n        delete PTHREAD_SPECIFIC[key];\r\n        return 0;\r\n      }\r\n      return ERRNO_CODES.EINVAL;\r\n    }\r\n\r\n  function _pthread_mutex_destroy() {}\r\n\r\n  function _pthread_mutex_init() {}\r\n\r\n   \r\n\r\n   \r\n\r\n  function _pthread_mutexattr_destroy() {}\r\n\r\n  function _pthread_mutexattr_init() {}\r\n\r\n  function _pthread_mutexattr_settype() {}\r\n\r\n  function _pthread_rwlock_rdlock() { return 0; }\r\n\r\n  function _pthread_rwlock_unlock() { return 0; }\r\n\r\n  function _pthread_rwlock_wrlock() { return 0; }\r\n\r\n  function _pthread_setspecific(key, value) {\r\n      if (!(key in PTHREAD_SPECIFIC)) {\r\n        return ERRNO_CODES.EINVAL;\r\n      }\r\n      PTHREAD_SPECIFIC[key] = value;\r\n      return 0;\r\n    }\r\n\r\n\r\n   \r\n\r\n  \r\n  function __isLeapYear(year) {\r\n        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);\r\n    }\r\n  \r\n  function __arraySum(array, index) {\r\n      var sum = 0;\r\n      for (var i = 0; i <= index; sum += array[i++]);\r\n      return sum;\r\n    }\r\n  \r\n  \r\n  var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];\r\n  \r\n  var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date, days) {\r\n      var newDate = new Date(date.getTime());\r\n      while(days > 0) {\r\n        var leap = __isLeapYear(newDate.getFullYear());\r\n        var currentMonth = newDate.getMonth();\r\n        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];\r\n  \r\n        if (days > daysInCurrentMonth-newDate.getDate()) {\r\n          // we spill over to next month\r\n          days -= (daysInCurrentMonth-newDate.getDate()+1);\r\n          newDate.setDate(1);\r\n          if (currentMonth < 11) {\r\n            newDate.setMonth(currentMonth+1)\r\n          } else {\r\n            newDate.setMonth(0);\r\n            newDate.setFullYear(newDate.getFullYear()+1);\r\n          }\r\n        } else {\r\n          // we stay in current month \r\n          newDate.setDate(newDate.getDate()+days);\r\n          return newDate;\r\n        }\r\n      }\r\n  \r\n      return newDate;\r\n    }function _strftime(s, maxsize, format, tm) {\r\n      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);\r\n      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html\r\n  \r\n      var tm_zone = HEAP32[(((tm)+(40))>>2)];\r\n  \r\n      var date = {\r\n        tm_sec: HEAP32[((tm)>>2)],\r\n        tm_min: HEAP32[(((tm)+(4))>>2)],\r\n        tm_hour: HEAP32[(((tm)+(8))>>2)],\r\n        tm_mday: HEAP32[(((tm)+(12))>>2)],\r\n        tm_mon: HEAP32[(((tm)+(16))>>2)],\r\n        tm_year: HEAP32[(((tm)+(20))>>2)],\r\n        tm_wday: HEAP32[(((tm)+(24))>>2)],\r\n        tm_yday: HEAP32[(((tm)+(28))>>2)],\r\n        tm_isdst: HEAP32[(((tm)+(32))>>2)],\r\n        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],\r\n        tm_zone: tm_zone ? Pointer_stringify(tm_zone) : ''\r\n      };\r\n  \r\n      var pattern = Pointer_stringify(format);\r\n  \r\n      // expand format\r\n      var EXPANSION_RULES_1 = {\r\n        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013\r\n        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y\r\n        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d\r\n        '%h': '%b',                       // Equivalent to %b\r\n        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation\r\n        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation\r\n        '%T': '%H:%M:%S',                 // Replaced by the time\r\n        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation\r\n        '%X': '%H:%M:%S'                  // Replaced by the locale's appropriate date representation\r\n      };\r\n      for (var rule in EXPANSION_RULES_1) {\r\n        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);\r\n      }\r\n  \r\n      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\r\n      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\r\n  \r\n      function leadingSomething(value, digits, character) {\r\n        var str = typeof value === 'number' ? value.toString() : (value || '');\r\n        while (str.length < digits) {\r\n          str = character[0]+str;\r\n        }\r\n        return str;\r\n      };\r\n  \r\n      function leadingNulls(value, digits) {\r\n        return leadingSomething(value, digits, '0');\r\n      };\r\n  \r\n      function compareByDay(date1, date2) {\r\n        function sgn(value) {\r\n          return value < 0 ? -1 : (value > 0 ? 1 : 0);\r\n        };\r\n  \r\n        var compare;\r\n        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {\r\n          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {\r\n            compare = sgn(date1.getDate()-date2.getDate());\r\n          }\r\n        }\r\n        return compare;\r\n      };\r\n  \r\n      function getFirstWeekStartDate(janFourth) {\r\n          switch (janFourth.getDay()) {\r\n            case 0: // Sunday\r\n              return new Date(janFourth.getFullYear()-1, 11, 29);\r\n            case 1: // Monday\r\n              return janFourth;\r\n            case 2: // Tuesday\r\n              return new Date(janFourth.getFullYear(), 0, 3);\r\n            case 3: // Wednesday\r\n              return new Date(janFourth.getFullYear(), 0, 2);\r\n            case 4: // Thursday\r\n              return new Date(janFourth.getFullYear(), 0, 1);\r\n            case 5: // Friday\r\n              return new Date(janFourth.getFullYear()-1, 11, 31);\r\n            case 6: // Saturday\r\n              return new Date(janFourth.getFullYear()-1, 11, 30);\r\n          }\r\n      };\r\n  \r\n      function getWeekBasedYear(date) {\r\n          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);\r\n  \r\n          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\r\n          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);\r\n  \r\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\r\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\r\n  \r\n          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\r\n            // this date is after the start of the first week of this year\r\n            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\r\n              return thisDate.getFullYear()+1;\r\n            } else {\r\n              return thisDate.getFullYear();\r\n            }\r\n          } else { \r\n            return thisDate.getFullYear()-1;\r\n          }\r\n      };\r\n  \r\n      var EXPANSION_RULES_2 = {\r\n        '%a': function(date) {\r\n          return WEEKDAYS[date.tm_wday].substring(0,3);\r\n        },\r\n        '%A': function(date) {\r\n          return WEEKDAYS[date.tm_wday];\r\n        },\r\n        '%b': function(date) {\r\n          return MONTHS[date.tm_mon].substring(0,3);\r\n        },\r\n        '%B': function(date) {\r\n          return MONTHS[date.tm_mon];\r\n        },\r\n        '%C': function(date) {\r\n          var year = date.tm_year+1900;\r\n          return leadingNulls((year/100)|0,2);\r\n        },\r\n        '%d': function(date) {\r\n          return leadingNulls(date.tm_mday, 2);\r\n        },\r\n        '%e': function(date) {\r\n          return leadingSomething(date.tm_mday, 2, ' ');\r\n        },\r\n        '%g': function(date) {\r\n          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year. \r\n          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes \r\n          // January 4th, which is also the week that includes the first Thursday of the year, and \r\n          // is also the first week that contains at least four days in the year. \r\n          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of \r\n          // the last week of the preceding year; thus, for Saturday 2nd January 1999, \r\n          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th, \r\n          // or 31st is a Monday, it and any following days are part of week 1 of the following year. \r\n          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.\r\n          \r\n          return getWeekBasedYear(date).toString().substring(2);\r\n        },\r\n        '%G': function(date) {\r\n          return getWeekBasedYear(date);\r\n        },\r\n        '%H': function(date) {\r\n          return leadingNulls(date.tm_hour, 2);\r\n        },\r\n        '%I': function(date) {\r\n          var twelveHour = date.tm_hour;\r\n          if (twelveHour == 0) twelveHour = 12;\r\n          else if (twelveHour > 12) twelveHour -= 12;\r\n          return leadingNulls(twelveHour, 2);\r\n        },\r\n        '%j': function(date) {\r\n          // Day of the year (001-366)\r\n          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);\r\n        },\r\n        '%m': function(date) {\r\n          return leadingNulls(date.tm_mon+1, 2);\r\n        },\r\n        '%M': function(date) {\r\n          return leadingNulls(date.tm_min, 2);\r\n        },\r\n        '%n': function() {\r\n          return '\\n';\r\n        },\r\n        '%p': function(date) {\r\n          if (date.tm_hour >= 0 && date.tm_hour < 12) {\r\n            return 'AM';\r\n          } else {\r\n            return 'PM';\r\n          }\r\n        },\r\n        '%S': function(date) {\r\n          return leadingNulls(date.tm_sec, 2);\r\n        },\r\n        '%t': function() {\r\n          return '\\t';\r\n        },\r\n        '%u': function(date) {\r\n          var day = new Date(date.tm_year+1900, date.tm_mon+1, date.tm_mday, 0, 0, 0, 0);\r\n          return day.getDay() || 7;\r\n        },\r\n        '%U': function(date) {\r\n          // Replaced by the week number of the year as a decimal number [00,53]. \r\n          // The first Sunday of January is the first day of week 1; \r\n          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]\r\n          var janFirst = new Date(date.tm_year+1900, 0, 1);\r\n          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7-janFirst.getDay());\r\n          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);\r\n          \r\n          // is target date after the first Sunday?\r\n          if (compareByDay(firstSunday, endDate) < 0) {\r\n            // calculate difference in days between first Sunday and endDate\r\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;\r\n            var firstSundayUntilEndJanuary = 31-firstSunday.getDate();\r\n            var days = firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();\r\n            return leadingNulls(Math.ceil(days/7), 2);\r\n          }\r\n  \r\n          return compareByDay(firstSunday, janFirst) === 0 ? '01': '00';\r\n        },\r\n        '%V': function(date) {\r\n          // Replaced by the week number of the year (Monday as the first day of the week) \r\n          // as a decimal number [01,53]. If the week containing 1 January has four \r\n          // or more days in the new year, then it is considered week 1. \r\n          // Otherwise, it is the last week of the previous year, and the next week is week 1. \r\n          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]\r\n          var janFourthThisYear = new Date(date.tm_year+1900, 0, 4);\r\n          var janFourthNextYear = new Date(date.tm_year+1901, 0, 4);\r\n  \r\n          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\r\n          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\r\n  \r\n          var endDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);\r\n  \r\n          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {\r\n            // if given date is before this years first week, then it belongs to the 53rd week of last year\r\n            return '53';\r\n          } \r\n  \r\n          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {\r\n            // if given date is after next years first week, then it belongs to the 01th week of next year\r\n            return '01';\r\n          }\r\n  \r\n          // given date is in between CW 01..53 of this calendar year\r\n          var daysDifference;\r\n          if (firstWeekStartThisYear.getFullYear() < date.tm_year+1900) {\r\n            // first CW of this year starts last year\r\n            daysDifference = date.tm_yday+32-firstWeekStartThisYear.getDate()\r\n          } else {\r\n            // first CW of this year starts this year\r\n            daysDifference = date.tm_yday+1-firstWeekStartThisYear.getDate();\r\n          }\r\n          return leadingNulls(Math.ceil(daysDifference/7), 2);\r\n        },\r\n        '%w': function(date) {\r\n          var day = new Date(date.tm_year+1900, date.tm_mon+1, date.tm_mday, 0, 0, 0, 0);\r\n          return day.getDay();\r\n        },\r\n        '%W': function(date) {\r\n          // Replaced by the week number of the year as a decimal number [00,53]. \r\n          // The first Monday of January is the first day of week 1; \r\n          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]\r\n          var janFirst = new Date(date.tm_year, 0, 1);\r\n          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7-janFirst.getDay()+1);\r\n          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);\r\n  \r\n          // is target date after the first Monday?\r\n          if (compareByDay(firstMonday, endDate) < 0) {\r\n            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;\r\n            var firstMondayUntilEndJanuary = 31-firstMonday.getDate();\r\n            var days = firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();\r\n            return leadingNulls(Math.ceil(days/7), 2);\r\n          }\r\n          return compareByDay(firstMonday, janFirst) === 0 ? '01': '00';\r\n        },\r\n        '%y': function(date) {\r\n          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]\r\n          return (date.tm_year+1900).toString().substring(2);\r\n        },\r\n        '%Y': function(date) {\r\n          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]\r\n          return date.tm_year+1900;\r\n        },\r\n        '%z': function(date) {\r\n          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).\r\n          // For example, \"-0430\" means 4 hours 30 minutes behind UTC (west of Greenwich).\r\n          var off = date.tm_gmtoff;\r\n          var ahead = off >= 0;\r\n          off = Math.abs(off) / 60;\r\n          // convert from minutes into hhmm format (which means 60 minutes = 100 units)\r\n          off = (off / 60)*100 + (off % 60);\r\n          return (ahead ? '+' : '-') + String(\"0000\" + off).slice(-4);\r\n        },\r\n        '%Z': function(date) {\r\n          return date.tm_zone;\r\n        },\r\n        '%%': function() {\r\n          return '%';\r\n        }\r\n      };\r\n      for (var rule in EXPANSION_RULES_2) {\r\n        if (pattern.indexOf(rule) >= 0) {\r\n          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));\r\n        }\r\n      }\r\n  \r\n      var bytes = intArrayFromString(pattern, false);\r\n      if (bytes.length > maxsize) {\r\n        return 0;\r\n      } \r\n  \r\n      writeArrayToMemory(bytes, s);\r\n      return bytes.length-1;\r\n    }\r\n\r\n  function _system(command) {\r\n      // int system(const char *command);\r\n      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html\r\n      // Can't call external programs.\r\n      ___setErrNo(ERRNO_CODES.EAGAIN);\r\n      return -1;\r\n    }\r\n\r\n\r\n  function _time(ptr) {\r\n      var ret = (Date.now()/1000)|0;\r\n      if (ptr) {\r\n        HEAP32[((ptr)>>2)]=ret;\r\n      }\r\n      return ret;\r\n    }\r\nif (ENVIRONMENT_IS_NODE) {\r\n    _emscripten_get_now = function _emscripten_get_now_actual() {\r\n      var t = process['hrtime']();\r\n      return t[0] * 1e3 + t[1] / 1e6;\r\n    };\r\n  } else if (typeof dateNow !== 'undefined') {\r\n    _emscripten_get_now = dateNow;\r\n  } else if (typeof self === 'object' && self['performance'] && typeof self['performance']['now'] === 'function') {\r\n    _emscripten_get_now = function() { return self['performance']['now'](); };\r\n  } else if (typeof performance === 'object' && typeof performance['now'] === 'function') {\r\n    _emscripten_get_now = function() { return performance['now'](); };\r\n  } else {\r\n    _emscripten_get_now = Date.now;\r\n  };\r\nFS.staticInit();__ATINIT__.unshift(function() { if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init() });__ATMAIN__.push(function() { FS.ignorePermissions = false });__ATEXIT__.push(function() { FS.quit() });;\r\n__ATINIT__.unshift(function() { TTY.init() });__ATEXIT__.push(function() { TTY.shutdown() });;\r\nif (ENVIRONMENT_IS_NODE) { var fs = require(\"fs\"); var NODEJS_PATH = require(\"path\"); NODEFS.staticInit(); };\r\n___buildEnvironment(ENV);;\r\nDYNAMICTOP_PTR = staticAlloc(4);\r\n\r\nSTACK_BASE = STACKTOP = alignMemory(STATICTOP);\r\n\r\nSTACK_MAX = STACK_BASE + TOTAL_STACK;\r\n\r\nDYNAMIC_BASE = alignMemory(STACK_MAX);\r\n\r\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\r\n\r\nstaticSealed = true; // seal the static portion of memory\r\n\r\nassert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\r\n\r\nvar ASSERTIONS = true;\r\n\r\n/** @type {function(string, boolean=, number=)} */\r\nfunction intArrayFromString(stringy, dontAddNull, length) {\r\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\r\n  var u8array = new Array(len);\r\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n  if (dontAddNull) u8array.length = numBytesWritten;\r\n  return u8array;\r\n}\r\n\r\nfunction intArrayToString(array) {\r\n  var ret = [];\r\n  for (var i = 0; i < array.length; i++) {\r\n    var chr = array[i];\r\n    if (chr > 0xFF) {\r\n      if (ASSERTIONS) {\r\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\r\n      }\r\n      chr &= 0xFF;\r\n    }\r\n    ret.push(String.fromCharCode(chr));\r\n  }\r\n  return ret.join('');\r\n}\r\n\r\n\r\n\r\nfunction nullFunc_i(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'i'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_ii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_iii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_iiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_iiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_ji(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'ji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_v(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_vi(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_vii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_viii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_viiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nfunction nullFunc_viiiiiii(x) { Module[\"printErr\"](\"Invalid function pointer called with signature 'viiiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");  Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");abort(x) }\r\n\r\nModule['wasmTableSize'] = 5376;\r\n\r\nModule['wasmMaxTableSize'] = 5376;\r\n\r\nfunction invoke_i(index) {\r\n  try {\r\n    return Module[\"dynCall_i\"](index);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_ii(index,a1) {\r\n  try {\r\n    return Module[\"dynCall_ii\"](index,a1);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iii(index,a1,a2) {\r\n  try {\r\n    return Module[\"dynCall_iii\"](index,a1,a2);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iiii(index,a1,a2,a3) {\r\n  try {\r\n    return Module[\"dynCall_iiii\"](index,a1,a2,a3);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_iiiii(index,a1,a2,a3,a4) {\r\n  try {\r\n    return Module[\"dynCall_iiiii\"](index,a1,a2,a3,a4);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_ji(index,a1) {\r\n  try {\r\n    return Module[\"dynCall_ji\"](index,a1);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_v(index) {\r\n  try {\r\n    Module[\"dynCall_v\"](index);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_vi(index,a1) {\r\n  try {\r\n    Module[\"dynCall_vi\"](index,a1);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_vii(index,a1,a2) {\r\n  try {\r\n    Module[\"dynCall_vii\"](index,a1,a2);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_viii(index,a1,a2,a3) {\r\n  try {\r\n    Module[\"dynCall_viii\"](index,a1,a2,a3);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_viiii(index,a1,a2,a3,a4) {\r\n  try {\r\n    Module[\"dynCall_viiii\"](index,a1,a2,a3,a4);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nfunction invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {\r\n  try {\r\n    Module[\"dynCall_viiiiiii\"](index,a1,a2,a3,a4,a5,a6,a7);\r\n  } catch(e) {\r\n    if (typeof e !== 'number' && e !== 'longjmp') throw e;\r\n    Module[\"setThrew\"](1, 0);\r\n  }\r\n}\r\n\r\nModule.asmGlobalArg = {};\r\n\r\nModule.asmLibraryArg = { \"abort\": abort, \"assert\": assert, \"enlargeMemory\": enlargeMemory, \"getTotalMemory\": getTotalMemory, \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory, \"abortStackOverflow\": abortStackOverflow, \"nullFunc_i\": nullFunc_i, \"nullFunc_ii\": nullFunc_ii, \"nullFunc_iii\": nullFunc_iii, \"nullFunc_iiii\": nullFunc_iiii, \"nullFunc_iiiii\": nullFunc_iiiii, \"nullFunc_ji\": nullFunc_ji, \"nullFunc_v\": nullFunc_v, \"nullFunc_vi\": nullFunc_vi, \"nullFunc_vii\": nullFunc_vii, \"nullFunc_viii\": nullFunc_viii, \"nullFunc_viiii\": nullFunc_viiii, \"nullFunc_viiiiiii\": nullFunc_viiiiiii, \"invoke_i\": invoke_i, \"invoke_ii\": invoke_ii, \"invoke_iii\": invoke_iii, \"invoke_iiii\": invoke_iiii, \"invoke_iiiii\": invoke_iiiii, \"invoke_ji\": invoke_ji, \"invoke_v\": invoke_v, \"invoke_vi\": invoke_vi, \"invoke_vii\": invoke_vii, \"invoke_viii\": invoke_viii, \"invoke_viiii\": invoke_viiii, \"invoke_viiiiiii\": invoke_viiiiiii, \"__Unwind_Backtrace\": __Unwind_Backtrace, \"__Unwind_FindEnclosingFunction\": __Unwind_FindEnclosingFunction, \"__Unwind_GetIPInfo\": __Unwind_GetIPInfo, \"__ZSt18uncaught_exceptionv\": __ZSt18uncaught_exceptionv, \"___assert_fail\": ___assert_fail, \"___buildEnvironment\": ___buildEnvironment, \"___clock_gettime\": ___clock_gettime, \"___cxa_allocate_exception\": ___cxa_allocate_exception, \"___cxa_find_matching_catch\": ___cxa_find_matching_catch, \"___cxa_find_matching_catch_2\": ___cxa_find_matching_catch_2, \"___cxa_throw\": ___cxa_throw, \"___gxx_personality_v0\": ___gxx_personality_v0, \"___lock\": ___lock, \"___map_file\": ___map_file, \"___resumeException\": ___resumeException, \"___setErrNo\": ___setErrNo, \"___syscall10\": ___syscall10, \"___syscall140\": ___syscall140, \"___syscall145\": ___syscall145, \"___syscall146\": ___syscall146, \"___syscall196\": ___syscall196, \"___syscall221\": ___syscall221, \"___syscall330\": ___syscall330, \"___syscall38\": ___syscall38, \"___syscall4\": ___syscall4, \"___syscall40\": ___syscall40, \"___syscall5\": ___syscall5, \"___syscall54\": ___syscall54, \"___syscall6\": ___syscall6, \"___syscall63\": ___syscall63, \"___syscall91\": ___syscall91, \"___unlock\": ___unlock, \"__addDays\": __addDays, \"__arraySum\": __arraySum, \"__emscripten_traverse_stack\": __emscripten_traverse_stack, \"__exit\": __exit, \"__isLeapYear\": __isLeapYear, \"_abort\": _abort, \"_clock\": _clock, \"_clock_gettime\": _clock_gettime, \"_difftime\": _difftime, \"_dladdr\": _dladdr, \"_emscripten_asm_const_i\": _emscripten_asm_const_i, \"_emscripten_asm_const_ii\": _emscripten_asm_const_ii, \"_emscripten_asm_const_iii\": _emscripten_asm_const_iii, \"_emscripten_asm_const_iiii\": _emscripten_asm_const_iiii, \"_emscripten_get_callstack_js\": _emscripten_get_callstack_js, \"_emscripten_get_now\": _emscripten_get_now, \"_emscripten_get_now_is_monotonic\": _emscripten_get_now_is_monotonic, \"_emscripten_memcpy_big\": _emscripten_memcpy_big, \"_exit\": _exit, \"_getenv\": _getenv, \"_gmtime\": _gmtime, \"_gmtime_r\": _gmtime_r, \"_llvm_pow_f64\": _llvm_pow_f64, \"_llvm_trap\": _llvm_trap, \"_localtime\": _localtime, \"_localtime_r\": _localtime_r, \"_longjmp\": _longjmp, \"_mktime\": _mktime, \"_pthread_cond_destroy\": _pthread_cond_destroy, \"_pthread_cond_init\": _pthread_cond_init, \"_pthread_condattr_destroy\": _pthread_condattr_destroy, \"_pthread_condattr_init\": _pthread_condattr_init, \"_pthread_condattr_setclock\": _pthread_condattr_setclock, \"_pthread_getspecific\": _pthread_getspecific, \"_pthread_key_create\": _pthread_key_create, \"_pthread_key_delete\": _pthread_key_delete, \"_pthread_mutex_destroy\": _pthread_mutex_destroy, \"_pthread_mutex_init\": _pthread_mutex_init, \"_pthread_mutexattr_destroy\": _pthread_mutexattr_destroy, \"_pthread_mutexattr_init\": _pthread_mutexattr_init, \"_pthread_mutexattr_settype\": _pthread_mutexattr_settype, \"_pthread_rwlock_rdlock\": _pthread_rwlock_rdlock, \"_pthread_rwlock_unlock\": _pthread_rwlock_unlock, \"_pthread_rwlock_wrlock\": _pthread_rwlock_wrlock, \"_pthread_setspecific\": _pthread_setspecific, \"_strftime\": _strftime, \"_system\": _system, \"_time\": _time, \"_tzset\": _tzset, \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR, \"tempDoublePtr\": tempDoublePtr, \"ABORT\": ABORT, \"STACKTOP\": STACKTOP, \"STACK_MAX\": STACK_MAX };\r\n// EMSCRIPTEN_START_ASM\r\nvar asm =Module[\"asm\"]// EMSCRIPTEN_END_ASM\r\n(Module.asmGlobalArg, Module.asmLibraryArg, buffer);\r\n\r\nvar real____errno_location = asm[\"___errno_location\"]; asm[\"___errno_location\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real____errno_location.apply(null, arguments);\r\n};\r\n\r\nvar real__execute_lua = asm[\"_execute_lua\"]; asm[\"_execute_lua\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__execute_lua.apply(null, arguments);\r\n};\r\n\r\nvar real__fflush = asm[\"_fflush\"]; asm[\"_fflush\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__fflush.apply(null, arguments);\r\n};\r\n\r\nvar real__free = asm[\"_free\"]; asm[\"_free\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__free.apply(null, arguments);\r\n};\r\n\r\nvar real__htonl = asm[\"_htonl\"]; asm[\"_htonl\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__htonl.apply(null, arguments);\r\n};\r\n\r\nvar real__htons = asm[\"_htons\"]; asm[\"_htons\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__htons.apply(null, arguments);\r\n};\r\n\r\nvar real__llvm_bswap_i16 = asm[\"_llvm_bswap_i16\"]; asm[\"_llvm_bswap_i16\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__llvm_bswap_i16.apply(null, arguments);\r\n};\r\n\r\nvar real__llvm_bswap_i32 = asm[\"_llvm_bswap_i32\"]; asm[\"_llvm_bswap_i32\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__llvm_bswap_i32.apply(null, arguments);\r\n};\r\n\r\nvar real__malloc = asm[\"_malloc\"]; asm[\"_malloc\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__malloc.apply(null, arguments);\r\n};\r\n\r\nvar real__ntohs = asm[\"_ntohs\"]; asm[\"_ntohs\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__ntohs.apply(null, arguments);\r\n};\r\n\r\nvar real__pthread_mutex_lock = asm[\"_pthread_mutex_lock\"]; asm[\"_pthread_mutex_lock\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__pthread_mutex_lock.apply(null, arguments);\r\n};\r\n\r\nvar real__pthread_mutex_unlock = asm[\"_pthread_mutex_unlock\"]; asm[\"_pthread_mutex_unlock\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__pthread_mutex_unlock.apply(null, arguments);\r\n};\r\n\r\nvar real__realloc = asm[\"_realloc\"]; asm[\"_realloc\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__realloc.apply(null, arguments);\r\n};\r\n\r\nvar real__saveSetjmp = asm[\"_saveSetjmp\"]; asm[\"_saveSetjmp\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__saveSetjmp.apply(null, arguments);\r\n};\r\n\r\nvar real__sbrk = asm[\"_sbrk\"]; asm[\"_sbrk\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__sbrk.apply(null, arguments);\r\n};\r\n\r\nvar real__testSetjmp = asm[\"_testSetjmp\"]; asm[\"_testSetjmp\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real__testSetjmp.apply(null, arguments);\r\n};\r\n\r\nvar real_establishStackSpace = asm[\"establishStackSpace\"]; asm[\"establishStackSpace\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real_establishStackSpace.apply(null, arguments);\r\n};\r\n\r\nvar real_getTempRet0 = asm[\"getTempRet0\"]; asm[\"getTempRet0\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real_getTempRet0.apply(null, arguments);\r\n};\r\n\r\nvar real_setTempRet0 = asm[\"setTempRet0\"]; asm[\"setTempRet0\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real_setTempRet0.apply(null, arguments);\r\n};\r\n\r\nvar real_setThrew = asm[\"setThrew\"]; asm[\"setThrew\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real_setThrew.apply(null, arguments);\r\n};\r\n\r\nvar real_stackAlloc = asm[\"stackAlloc\"]; asm[\"stackAlloc\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real_stackAlloc.apply(null, arguments);\r\n};\r\n\r\nvar real_stackRestore = asm[\"stackRestore\"]; asm[\"stackRestore\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real_stackRestore.apply(null, arguments);\r\n};\r\n\r\nvar real_stackSave = asm[\"stackSave\"]; asm[\"stackSave\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return real_stackSave.apply(null, arguments);\r\n};\r\nModule[\"asm\"] = asm;\r\nvar ___errno_location = Module[\"___errno_location\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"___errno_location\"].apply(null, arguments) };\r\nvar _execute_lua = Module[\"_execute_lua\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_execute_lua\"].apply(null, arguments) };\r\nvar _fflush = Module[\"_fflush\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_fflush\"].apply(null, arguments) };\r\nvar _free = Module[\"_free\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_free\"].apply(null, arguments) };\r\nvar _htonl = Module[\"_htonl\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_htonl\"].apply(null, arguments) };\r\nvar _htons = Module[\"_htons\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_htons\"].apply(null, arguments) };\r\nvar _llvm_bswap_i16 = Module[\"_llvm_bswap_i16\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_llvm_bswap_i16\"].apply(null, arguments) };\r\nvar _llvm_bswap_i32 = Module[\"_llvm_bswap_i32\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_llvm_bswap_i32\"].apply(null, arguments) };\r\nvar _malloc = Module[\"_malloc\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_malloc\"].apply(null, arguments) };\r\nvar _memcpy = Module[\"_memcpy\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_memcpy\"].apply(null, arguments) };\r\nvar _memset = Module[\"_memset\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_memset\"].apply(null, arguments) };\r\nvar _ntohs = Module[\"_ntohs\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_ntohs\"].apply(null, arguments) };\r\nvar _pthread_mutex_lock = Module[\"_pthread_mutex_lock\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_pthread_mutex_lock\"].apply(null, arguments) };\r\nvar _pthread_mutex_unlock = Module[\"_pthread_mutex_unlock\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_pthread_mutex_unlock\"].apply(null, arguments) };\r\nvar _realloc = Module[\"_realloc\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_realloc\"].apply(null, arguments) };\r\nvar _saveSetjmp = Module[\"_saveSetjmp\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_saveSetjmp\"].apply(null, arguments) };\r\nvar _sbrk = Module[\"_sbrk\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_sbrk\"].apply(null, arguments) };\r\nvar _testSetjmp = Module[\"_testSetjmp\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"_testSetjmp\"].apply(null, arguments) };\r\nvar establishStackSpace = Module[\"establishStackSpace\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments) };\r\nvar getTempRet0 = Module[\"getTempRet0\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"getTempRet0\"].apply(null, arguments) };\r\nvar runPostSets = Module[\"runPostSets\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"runPostSets\"].apply(null, arguments) };\r\nvar setTempRet0 = Module[\"setTempRet0\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"setTempRet0\"].apply(null, arguments) };\r\nvar setThrew = Module[\"setThrew\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"setThrew\"].apply(null, arguments) };\r\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments) };\r\nvar stackRestore = Module[\"stackRestore\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments) };\r\nvar stackSave = Module[\"stackSave\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments) };\r\nvar dynCall_i = Module[\"dynCall_i\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_i\"].apply(null, arguments) };\r\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments) };\r\nvar dynCall_iii = Module[\"dynCall_iii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_iii\"].apply(null, arguments) };\r\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments) };\r\nvar dynCall_iiiii = Module[\"dynCall_iiiii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_iiiii\"].apply(null, arguments) };\r\nvar dynCall_ji = Module[\"dynCall_ji\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_ji\"].apply(null, arguments) };\r\nvar dynCall_v = Module[\"dynCall_v\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_v\"].apply(null, arguments) };\r\nvar dynCall_vi = Module[\"dynCall_vi\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments) };\r\nvar dynCall_vii = Module[\"dynCall_vii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments) };\r\nvar dynCall_viii = Module[\"dynCall_viii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_viii\"].apply(null, arguments) };\r\nvar dynCall_viiii = Module[\"dynCall_viiii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments) };\r\nvar dynCall_viiiiiii = Module[\"dynCall_viiiiiii\"] = function() {\r\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\r\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\r\n  return Module[\"asm\"][\"dynCall_viiiiiii\"].apply(null, arguments) };\r\n;\r\n\r\n\r\n\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\nModule['asm'] = asm;\r\n\r\nif (!Module[\"intArrayFromString\"]) Module[\"intArrayFromString\"] = function() { abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function() { abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nModule[\"ccall\"] = ccall;\r\nModule[\"cwrap\"] = cwrap;\r\nif (!Module[\"setValue\"]) Module[\"setValue\"] = function() { abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"getValue\"]) Module[\"getValue\"] = function() { abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"allocate\"]) Module[\"allocate\"] = function() { abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"getMemory\"]) Module[\"getMemory\"] = function() { abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"Pointer_stringify\"]) Module[\"Pointer_stringify\"] = function() { abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function() { abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function() { abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function() { abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function() { abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function() { abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function() { abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function() { abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function() { abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function() { abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function() { abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function() { abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function() { abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function() { abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function() { abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function() { abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nModule[\"addOnInit\"] = addOnInit;\r\nif (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function() { abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function() { abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function() { abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function() { abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function() { abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function() { abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function() { abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function() { abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nModule[\"FS\"] = FS;\r\nif (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function() { abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function() { abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function() { abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function() { abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function() { abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function() { abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function() { abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function() { abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\r\nif (!Module[\"GL\"]) Module[\"GL\"] = function() { abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"staticAlloc\"]) Module[\"staticAlloc\"] = function() { abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function() { abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function() { abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function() { abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function() { abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"getLEB\"]) Module[\"getLEB\"] = function() { abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function() { abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function() { abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function() { abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"addFunction\"]) Module[\"addFunction\"] = function() { abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function() { abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function() { abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function() { abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function() { abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"dynCall\"]) Module[\"dynCall\"] = function() { abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function() { abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stackSave\"]) Module[\"stackSave\"] = function() { abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function() { abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\r\nif (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function() { abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };if (!Module[\"ALLOC_NORMAL\"]) Object.defineProperty(Module, \"ALLOC_NORMAL\", { get: function() { abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\r\nif (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", { get: function() { abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\r\nif (!Module[\"ALLOC_STATIC\"]) Object.defineProperty(Module, \"ALLOC_STATIC\", { get: function() { abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\r\nif (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", { get: function() { abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\r\nif (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", { get: function() { abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\r\n\r\n\r\n\r\n\r\n/**\r\n * @constructor\r\n * @extends {Error}\r\n * @this {ExitStatus}\r\n */\r\nfunction ExitStatus(status) {\r\n  this.name = \"ExitStatus\";\r\n  this.message = \"Program terminated with exit(\" + status + \")\";\r\n  this.status = status;\r\n};\r\nExitStatus.prototype = new Error();\r\nExitStatus.prototype.constructor = ExitStatus;\r\n\r\nvar initialStackTop;\r\nvar calledMain = false;\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n  if (!Module['calledRun']) run();\r\n  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/** @type {function(Array=)} */\r\nfunction run(args) {\r\n  args = args || Module['arguments'];\r\n\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n  writeStackCookie();\r\n\r\n  preRun();\r\n\r\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\r\n  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\r\n\r\n  function doRun() {\r\n    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\r\n    Module['calledRun'] = true;\r\n\r\n    if (ABORT) return;\r\n\r\n    ensureInitRuntime();\r\n\r\n    preMain();\r\n\r\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\r\n\r\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module['setStatus']) {\r\n    Module['setStatus']('Running...');\r\n    setTimeout(function() {\r\n      setTimeout(function() {\r\n        Module['setStatus']('');\r\n      }, 1);\r\n      doRun();\r\n    }, 1);\r\n  } else {\r\n    doRun();\r\n  }\r\n  checkStackCookie();\r\n}\r\nModule['run'] = run;\r\n\r\nfunction checkUnflushedContent() {\r\n  // Compiler settings do not allow exiting the runtime, so flushing\r\n  // the streams is not possible. but in ASSERTIONS mode we check\r\n  // if there was something to flush, and if so tell the user they\r\n  // should request that the runtime be exitable.\r\n  // Normally we would not even include flush() at all, but in ASSERTIONS\r\n  // builds we do so just for this check, and here we see if there is any\r\n  // content to flush, that is, we check if there would have been\r\n  // something a non-ASSERTIONS build would have not seen.\r\n  // How we flush the streams depends on whether we are in NO_FILESYSTEM\r\n  // mode (which has its own special function for this; otherwise, all\r\n  // the code is inside libc)\r\n  var print = Module['print'];\r\n  var printErr = Module['printErr'];\r\n  var has = false;\r\n  Module['print'] = Module['printErr'] = function(x) {\r\n    has = true;\r\n  }\r\n  try { // it doesn't matter if it fails\r\n    var flush = Module['_fflush'];\r\n    if (flush) flush(0);\r\n    // also flush in the JS FS layer\r\n    var hasFS = true;\r\n    if (hasFS) {\r\n      ['stdout', 'stderr'].forEach(function(name) {\r\n        var info = FS.analyzePath('/dev/' + name);\r\n        if (!info) return;\r\n        var stream = info.object;\r\n        var rdev = stream.rdev;\r\n        var tty = TTY.ttys[rdev];\r\n        if (tty && tty.output && tty.output.length) {\r\n          has = true;\r\n        }\r\n      });\r\n    }\r\n  } catch(e) {}\r\n  Module['print'] = print;\r\n  Module['printErr'] = printErr;\r\n  if (has) {\r\n    warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');\r\n  }\r\n}\r\n\r\nfunction exit(status, implicit) {\r\n  checkUnflushedContent();\r\n\r\n  // if this is just main exit-ing implicitly, and the status is 0, then we\r\n  // don't need to do anything here and can just leave. if the status is\r\n  // non-zero, though, then we need to report it.\r\n  // (we may have warned about this earlier, if a situation justifies doing so)\r\n  if (implicit && Module['noExitRuntime'] && status === 0) {\r\n    return;\r\n  }\r\n\r\n  if (Module['noExitRuntime']) {\r\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\r\n    if (!implicit) {\r\n      Module.printErr('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');\r\n    }\r\n  } else {\r\n\r\n    ABORT = true;\r\n    EXITSTATUS = status;\r\n    STACKTOP = initialStackTop;\r\n\r\n    exitRuntime();\r\n\r\n    if (Module['onExit']) Module['onExit'](status);\r\n  }\r\n\r\n  if (ENVIRONMENT_IS_NODE) {\r\n    process['exit'](status);\r\n  }\r\n  Module['quit'](status, new ExitStatus(status));\r\n}\r\nModule['exit'] = exit;\r\n\r\nvar abortDecorators = [];\r\n\r\nfunction abort(what) {\r\n  if (Module['onAbort']) {\r\n    Module['onAbort'](what);\r\n  }\r\n\r\n  if (what !== undefined) {\r\n    Module.print(what);\r\n    Module.printErr(what);\r\n    what = JSON.stringify(what)\r\n  } else {\r\n    what = '';\r\n  }\r\n\r\n  ABORT = true;\r\n  EXITSTATUS = 1;\r\n\r\n  var extra = '';\r\n  var output = 'abort(' + what + ') at ' + stackTrace() + extra;\r\n  if (abortDecorators) {\r\n    abortDecorators.forEach(function(decorator) {\r\n      output = decorator(output, what);\r\n    });\r\n  }\r\n  throw output;\r\n}\r\nModule['abort'] = abort;\r\n\r\n// {{PRE_RUN_ADDITIONS}}\r\n\r\nif (Module['preInit']) {\r\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n  while (Module['preInit'].length > 0) {\r\n    Module['preInit'].pop()();\r\n  }\r\n}\r\n\r\n\r\nModule[\"noExitRuntime\"] = true;\r\n\r\nrun();\r\n\r\n// {{POST_RUN_ADDITIONS}}\r\n\r\n\r\n\r\n\r\n\r\n// {{MODULE_ADDITIONS}}\r\n\r\n\r\n\r\n\n\n          });\n        }\n      }\n    })({\"wasmBinaryFile\":\"dist\\\\rust_lua.wasm\",\"ENVIRONMENT\":\"WEB\"})","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"app\"}},[_c('Editor',{staticClass:\"editor\"}),_vm._v(\" \"),_c('Output',{staticClass:\"out\"})],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"editor\"},[_c('monaco',{attrs:{\"language\":\"lua\",\"code\":_vm.code},on:{\"mounted\":_vm.editorMounted}}),_vm._v(\" \"),_c('button',{staticClass:\"run\",on:{\"click\":_vm.exeLua}},[_vm._v(\"Run script\")])],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div class=\"editor\">\n    <monaco\n      language=\"lua\"\n      :code=\"code\"\n      @mounted=\"editorMounted\"/>\n    <button class=\"run\" @click=\"exeLua\">Run script</button>\n  </div>\n</template>\n\n<script>\nimport Monaco from 'monaco-editor-forvue';\n \nexport default {\n  name: 'Editor',\n  props: {},\n  data() {\n    return {\n      code: `print(\"Hello, world!\")`\n    }\n  },\n  methods: {\n    editorMounted(editor) {\n      this.editor = editor;\n      editor.layout();\n    },\n    exeLua() {\n      this.$lua.executeLua(this.editor.getValue())\n    }\n  },\n  mounted() {\n    window.addEventListener(\"resize\", () => {\n      this.editor.layout()\n    })\n    window.run = this.exeLua\n  },\n  components: {\n    Monaco\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n.editor {\n  height: 100%;\n  width: 100%;\n  flex-grow: 1;\n}\n\n.run {\n  position: absolute;\n  bottom: 0px;left: 25%;\n  -webkit-transform: translateX(-50%);\n  transform: translateX(-50%)\n}\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--11-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Editor.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--11-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Editor.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Editor.vue?vue&type=template&id=57912f4c&scoped=true\"\nimport script from \"./Editor.vue?vue&type=script&lang=js\"\nexport * from \"./Editor.vue?vue&type=script&lang=js\"\nimport style0 from \"./Editor.vue?vue&type=style&index=0&id=57912f4c&scoped=true&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"57912f4c\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"out\",attrs:{\"tabindex\":\"1\"},on:{\"keydown\":_vm.keypress}},[_vm._l((_vm.output),function(char,i){return _c('span',{key:char+i,class:char.color},[_vm._v(_vm._s(char.char)),(char.char=='\\n')?_c('br'):_vm._e()])}),_vm._v(\" \"),_c('span',{staticClass:\"cursor\"},[_vm._v(\"_\")])],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import rust_lua from './rust-lua/src/main.rs'\r\nimport Vue from 'vue'\r\n\r\nexport default class LuaEngine {\r\n    constructor() {\r\n        this.EventBus = new Vue()\r\n\r\n        this.output = ''\r\n        this.error = ''\r\n        this.input = []\r\n        this.scriptIndex = 0\r\n\r\n        rust_lua.initialize({\r\n            noFSInit: true\r\n        }).then(mod => {\r\n            console.log(mod)\r\n            this.FS = mod.FS\r\n            this.FS.mkdir('/data')\r\n            this.FS.mount(this.FS.filesystems.IDBFS, {}, '/data')\r\n            window.syncfs = this.FS.syncfs//\r\n            this.FS.syncfs(true, function(err) {\r\n                if(err) throw err\r\n            })\r\n\r\n            let wait = (seconds) => \r\n            new Promise(resolve => \r\n               setTimeout(() => resolve(), seconds * 1000)\r\n            );\r\n\r\n            let stdin = () => {\r\n                if(this.input.length == 0) {\r\n                    let promptres = window.prompt('Please enter your input. Press \"cancel\" when finished.')\r\n                    if(promptres == null) {\r\n                        return null\r\n                    }\r\n                    this.input = (promptres + '\\n').split('')\r\n                }\r\n                let char = this.input.shift()\r\n                return char.charCodeAt(0)\r\n            }\r\n            let stdout = ascii => {\r\n                this.EventBus.$emit('STDOUT', String.fromCharCode(ascii))\r\n            }\r\n            let stderr = ascii => {\r\n                this.EventBus.$emit('STDERR', String.fromCharCode(ascii))\r\n            }\r\n            \r\n            this.FS.init(stdin, stdout, stderr)\r\n            this.Module = mod\r\n            this._executeLua = mod.cwrap('execute_lua', 'void', ['string'])\r\n            this.executeLua = (code) => {\r\n                this.scriptIndex++\r\n                `\\nRunning script (${this.scriptIndex})...\\n`.split('').forEach(c => this.EventBus.$emit('STDOUT', c, 'green'))\r\n                this._executeLua(code)\r\n            }\r\n        })\r\n    }\r\n\r\n    executeLua(luastr) {\r\n        console.error('Lua VM not initialized yet')\r\n    }\r\n}\r\n\r\nLuaEngine.install = function(Vue) {\r\n    Object.defineProperty(Vue.prototype, '$lua', {\r\n        get() {\r\n            return this.$root._luaEngine\r\n        }\r\n    })\r\n\r\n    Vue.mixin({\r\n        beforeCreate() {\r\n            if(this.$options.luaEngine) {\r\n                this._luaEngine = this.$options.luaEngine\r\n            }\r\n        }\r\n    })\r\n}","import Vue from 'vue'\r\nimport LuaEngine from './lua'\r\n\r\nVue.use(LuaEngine)\r\n\r\nexport default new LuaEngine()\r\n","<template>\n  <div class=\"out\" @keydown=\"keypress\" tabindex=\"1\">\n    <span v-for=\"(char, i) of output\" :key=\"char+i\" :class=\"char.color\">{{char.char}}<br v-if=\"char.char=='\\n'\"/></span>\n    <span class=\"cursor\">_</span>\n  </div>\n</template>\n\n<script>\nimport Monaco from 'monaco-editor-forvue'\nimport luaEngine from '../lua'\n\nexport default {\n  name: 'Output',\n  props: {},\n  data() {\n    return {\n      output: []\n    }\n  },\n  methods: {\n    keypress(e) {\n      if(e.key.length == 1) {\n        luaEngine.EventBus.$emit('STDIN', e)\n      }\n    }\n  },\n  mounted() {\n    luaEngine.EventBus.$on('STDOUT', (text, color) => {\n      this.output.push({\n        char: text,\n        color: color || ''\n      })\n      this.$nextTick(() => {\n        this.$el.scrollTop = this.$el.scrollHeight;\n      })\n    })\n    luaEngine.EventBus.$on('STDERR', text => {\n      this.output.push({\n        char: text,\n        color: 'error'\n      })\n      this.$nextTick(() => {\n        this.$el.scrollTop = this.$el.scrollHeight;\n      })\n    })\n  },\n  components: {\n    Monaco\n  }\n}\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped lang=\"scss\">\n.out {\n  flex-grow: 1;\n  height: calc(100vh - 10px);\n  overflow-y: auto;\n  padding: 5px;\n  color: #d4d4d4;\n  background-color: #1e1e1e;\n  font-family: Consolas, \"Courier New\", monospace;\n\n  .cursor {\n    //outline: 1px #d4d4d4 solid;\n    box-shadow:inset 0px 0px 0px 1px #d4d4d4;\n    color: rgba(0, 0, 0, 0);\n    background: rgba(0, 0, 0, 0);\n  }\n\n  &:focus {\n    outline: none;\n\n    .cursor {\n      background: #d4d4d4;\n    }\n  }\n  \n  &::-webkit-scrollbar {\n    width: 14px;\n    background-color: transparent;\n    border-left: 1px hsla(0,0%,47%,0.4) solid;\n  }\n\n  &:hover {\n    &::-webkit-scrollbar-thumb {\n      background-color: hsla(0,0%,47%,0.4);\n      opacity: 0.4;\n    }\n  }\n\n  &::-webkit-scrollbar-thumb {\n    background-color: hsla(0,0%,47%,0);\n    opacity: 0;\n    transition: opacity .8s linear;\n  }\n\n  &::-webkit-scrollbar-thumb:hover {\n    background-color: hsla(0,0%,47%,0.7);\n    opacity: 0.7;\n  }\n}\n.error {\n  color: #F14C4C;\n}\n\n.green {\n  color: #4CF14C;\n}\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--11-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Output.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--11-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Output.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./Output.vue?vue&type=template&id=3bc037aa&scoped=true\"\nimport script from \"./Output.vue?vue&type=script&lang=js\"\nexport * from \"./Output.vue?vue&type=script&lang=js\"\nimport style0 from \"./Output.vue?vue&type=style&index=0&id=3bc037aa&scoped=true&lang=scss\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"3bc037aa\",\n  null\n  \n)\n\nexport default component.exports","<template>\n  <div id=\"app\">\n    <Editor class=\"editor\"/>\n    <Output class=\"out\"/>\n  </div>\n</template>\n\n<script>\nimport Editor from './components/Editor.vue'\nimport Output from './components/Output.vue'\n\nexport default {\n  name: 'app',\n  components: {\n    Editor,\n    Output,\n  }\n}\n</script>\n\n<style>\n#app {\n  display: grid;\n  grid-template-columns: 50vw 50vw;\n  grid-template-rows: 100vh;\n  grid-gap: 1px;\n  height: 100%;\n  background: #383838;\n  overflow: hidden;\n}\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--11-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--11-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=77c37c07\"\nimport script from \"./App.vue?vue&type=script&lang=js\"\nexport * from \"./App.vue?vue&type=script&lang=js\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=css\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import Vue from 'vue'\nimport App from './App.vue'\nimport luaEngine from './lua'\nimport './main.scss'\n\nVue.config.productionTip = false\n\nnew Vue({\n  luaEngine,\n  render: h => h(App)\n}).$mount('#app')\n","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/lib/index.js??ref--6-oneOf-1-2!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=css\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js!../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/lib/index.js??ref--6-oneOf-1-2!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=css\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/lib/index.js??ref--6-oneOf-1-2!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Editor.vue?vue&type=style&index=0&id=57912f4c&scoped=true&lang=css\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/index.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/lib/index.js??ref--6-oneOf-1-2!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Editor.vue?vue&type=style&index=0&id=57912f4c&scoped=true&lang=css\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/index.js??ref--7-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/lib/index.js??ref--7-oneOf-1-2!../../node_modules/sass-loader/lib/loader.js??ref--7-oneOf-1-3!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Output.vue?vue&type=style&index=0&id=3bc037aa&scoped=true&lang=scss\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/index.js??ref--7-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/lib/index.js??ref--7-oneOf-1-2!../../node_modules/sass-loader/lib/loader.js??ref--7-oneOf-1-3!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Output.vue?vue&type=style&index=0&id=3bc037aa&scoped=true&lang=scss\""],"sourceRoot":""}